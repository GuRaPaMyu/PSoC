ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_initVar
  18              		.bss
  19              		.type	UART_initVar, %object
  20              		.size	UART_initVar, 1
  21              	UART_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_Start, %function
  29              	UART_Start:
  30              	.LFB0:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART.c"
   1:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART.c **** * File Name: UART.c
   3:.\Generated_Source\PSoC4/UART.c **** * Version 2.50
   4:.\Generated_Source\PSoC4/UART.c **** *
   5:.\Generated_Source\PSoC4/UART.c **** * Description:
   6:.\Generated_Source\PSoC4/UART.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART.c **** *
   8:.\Generated_Source\PSoC4/UART.c **** * Note:
   9:.\Generated_Source\PSoC4/UART.c **** *
  10:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART.c **** 
  17:.\Generated_Source\PSoC4/UART.c **** #include "UART.h"
  18:.\Generated_Source\PSoC4/UART.c **** #if (UART_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC4/UART.c ****     #include "UART_IntClock.h"
  20:.\Generated_Source\PSoC4/UART.c **** #endif /* End UART_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC4/UART.c **** 
  22:.\Generated_Source\PSoC4/UART.c **** 
  23:.\Generated_Source\PSoC4/UART.c **** /***************************************
  24:.\Generated_Source\PSoC4/UART.c **** * Global data allocation
  25:.\Generated_Source\PSoC4/UART.c **** ***************************************/
  26:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 2


  27:.\Generated_Source\PSoC4/UART.c **** uint8 UART_initVar = 0u;
  28:.\Generated_Source\PSoC4/UART.c **** 
  29:.\Generated_Source\PSoC4/UART.c **** #if (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED)
  30:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_txBuffer[UART_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART.c **** #endif /* (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED) */
  34:.\Generated_Source\PSoC4/UART.c **** 
  35:.\Generated_Source\PSoC4/UART.c **** #if (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED))
  36:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_errorStatus = 0u;
  37:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBuffer[UART_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC4/UART.c ****         volatile uint8 UART_rxAddressMode = UART_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC4/UART.c ****         volatile uint8 UART_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC4/UART.c **** #endif /* (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED)) */
  47:.\Generated_Source\PSoC4/UART.c **** 
  48:.\Generated_Source\PSoC4/UART.c **** 
  49:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Start
  51:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  52:.\Generated_Source\PSoC4/UART.c **** *
  53:.\Generated_Source\PSoC4/UART.c **** * Summary:
  54:.\Generated_Source\PSoC4/UART.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC4/UART.c **** *  UART_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC4/UART.c **** *  UART_Init() function, and then calls the
  57:.\Generated_Source\PSoC4/UART.c **** *  UART_Enable() function.
  58:.\Generated_Source\PSoC4/UART.c **** *
  59:.\Generated_Source\PSoC4/UART.c **** * Parameters:
  60:.\Generated_Source\PSoC4/UART.c **** *  None.
  61:.\Generated_Source\PSoC4/UART.c **** *
  62:.\Generated_Source\PSoC4/UART.c **** * Return:
  63:.\Generated_Source\PSoC4/UART.c **** *  None.
  64:.\Generated_Source\PSoC4/UART.c **** *
  65:.\Generated_Source\PSoC4/UART.c **** * Global variables:
  66:.\Generated_Source\PSoC4/UART.c **** *  The UART_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC4/UART.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC4/UART.c **** *  and set to one (1u) the first time UART_Start() is called. This
  69:.\Generated_Source\PSoC4/UART.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC4/UART.c **** *  subsequent calls to the UART_Start() routine.
  71:.\Generated_Source\PSoC4/UART.c **** *
  72:.\Generated_Source\PSoC4/UART.c **** * Reentrant:
  73:.\Generated_Source\PSoC4/UART.c **** *  No.
  74:.\Generated_Source\PSoC4/UART.c **** *
  75:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC4/UART.c **** void UART_Start(void) 
  77:.\Generated_Source\PSoC4/UART.c **** {
  32              		.loc 1 77 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 3


  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC4/UART.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC4/UART.c ****     if(UART_initVar == 0u)
  40              		.loc 1 79 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC4/UART.c ****     {
  81:.\Generated_Source\PSoC4/UART.c ****         UART_Init();
  45              		.loc 1 81 0
  46 000c FFF7FEFF 		bl	UART_Init
  82:.\Generated_Source\PSoC4/UART.c ****         UART_initVar = 1u;
  47              		.loc 1 82 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  83:.\Generated_Source\PSoC4/UART.c ****     }
  84:.\Generated_Source\PSoC4/UART.c **** 
  85:.\Generated_Source\PSoC4/UART.c ****     UART_Enable();
  52              		.loc 1 85 0
  53 0016 FFF7FEFF 		bl	UART_Enable
  86:.\Generated_Source\PSoC4/UART.c **** }
  54              		.loc 1 86 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_initVar
  62              		.cfi_endproc
  63              	.LFE0:
  64              		.size	UART_Start, .-UART_Start
  65              		.section	.text.UART_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_Init, %function
  71              	UART_Init:
  72              	.LFB1:
  87:.\Generated_Source\PSoC4/UART.c **** 
  88:.\Generated_Source\PSoC4/UART.c **** 
  89:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Init
  91:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  92:.\Generated_Source\PSoC4/UART.c **** *
  93:.\Generated_Source\PSoC4/UART.c **** * Summary:
  94:.\Generated_Source\PSoC4/UART.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC4/UART.c **** *  dialog settings. It is not necessary to call UART_Init() because
  96:.\Generated_Source\PSoC4/UART.c **** *  the UART_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC4/UART.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC4/UART.c **** *
  99:.\Generated_Source\PSoC4/UART.c **** * Parameters:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 4


 100:.\Generated_Source\PSoC4/UART.c **** *  None.
 101:.\Generated_Source\PSoC4/UART.c **** *
 102:.\Generated_Source\PSoC4/UART.c **** * Return:
 103:.\Generated_Source\PSoC4/UART.c **** *  None.
 104:.\Generated_Source\PSoC4/UART.c **** *
 105:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC4/UART.c **** void UART_Init(void) 
 107:.\Generated_Source\PSoC4/UART.c **** {
  73              		.loc 1 107 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC4/UART.c ****     #if(UART_RX_ENABLED || UART_HD_ENABLED)
 109:.\Generated_Source\PSoC4/UART.c **** 
 110:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC4/UART.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC4/UART.c ****             (void) CyIntSetVector(UART_RX_VECT_NUM, &UART_RXISR);
 113:.\Generated_Source\PSoC4/UART.c ****             CyIntSetPriority(UART_RX_VECT_NUM, UART_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC4/UART.c ****             UART_errorStatus = 0u;
 115:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC4/UART.c **** 
 117:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddressMode(UART_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddress1(UART_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddress2(UART_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC4/UART.c **** 
 123:.\Generated_Source\PSoC4/UART.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_PERIOD_REG = UART_RXBITCTR_INIT;
 125:.\Generated_Source\PSoC4/UART.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_MASK_REG  = UART_INIT_RX_INTERRUPTS_MASK;
 127:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 128:.\Generated_Source\PSoC4/UART.c **** 
 129:.\Generated_Source\PSoC4/UART.c ****     #if(UART_TX_ENABLED)
 130:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC4/UART.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC4/UART.c ****             (void) CyIntSetVector(UART_TX_VECT_NUM, &UART_TXISR);
 133:.\Generated_Source\PSoC4/UART.c ****             CyIntSetPriority(UART_TX_VECT_NUM, UART_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC4/UART.c **** 
 136:.\Generated_Source\PSoC4/UART.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCLKGEN_CTR_REG = UART_BIT_CENTER;
  81              		.loc 1 138 0
  82 0004 054B     		ldr	r3, .L6
  83 0006 0622     		mov	r2, #6
  84 0008 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCLKTX_COMPLETE_REG = ((UART_NUMBER_OF_DATA_BITS +
  85              		.loc 1 139 0
  86 000a 054B     		ldr	r3, .L6+4
  87 000c 4722     		mov	r2, #71
  88 000e 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC4/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_COUNT) - 1u;
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 5


 141:.\Generated_Source\PSoC4/UART.c ****         #else
 142:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_PERIOD_REG = ((UART_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC4/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC4/UART.c **** 
 146:.\Generated_Source\PSoC4/UART.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC4/UART.c ****             UART_TXSTATUS_MASK_REG = UART_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC4/UART.c ****         #else
 150:.\Generated_Source\PSoC4/UART.c ****             UART_TXSTATUS_MASK_REG = UART_INIT_TX_INTERRUPTS_MASK;
  89              		.loc 1 150 0
  90 0010 044B     		ldr	r3, .L6+8
  91 0012 0022     		mov	r2, #0
  92 0014 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC4/UART.c ****         #endif /*End UART_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC4/UART.c **** 
 153:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_TX_ENABLED */
 154:.\Generated_Source\PSoC4/UART.c **** 
 155:.\Generated_Source\PSoC4/UART.c ****     #if(UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC4/UART.c ****         UART_WriteControlRegister( \
 157:.\Generated_Source\PSoC4/UART.c ****             (UART_ReadControlRegister() & (uint8)~UART_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC4/UART.c ****             (uint8)(UART_PARITY_TYPE << UART_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC4/UART.c **** }
  93              		.loc 1 160 0
  94 0016 BD46     		mov	sp, r7
  95              		@ sp needed
  96 0018 80BD     		pop	{r7, pc}
  97              	.L7:
  98 001a C046     		.align	2
  99              	.L6:
 100 001c 22000F40 		.word	1074724898
 101 0020 32000F40 		.word	1074724914
 102 0024 83000F40 		.word	1074724995
 103              		.cfi_endproc
 104              	.LFE1:
 105              		.size	UART_Init, .-UART_Init
 106              		.section	.text.UART_Enable,"ax",%progbits
 107              		.align	2
 108              		.global	UART_Enable
 109              		.code	16
 110              		.thumb_func
 111              		.type	UART_Enable, %function
 112              	UART_Enable:
 113              	.LFB2:
 161:.\Generated_Source\PSoC4/UART.c **** 
 162:.\Generated_Source\PSoC4/UART.c **** 
 163:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Enable
 165:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 166:.\Generated_Source\PSoC4/UART.c **** *
 167:.\Generated_Source\PSoC4/UART.c **** * Summary:
 168:.\Generated_Source\PSoC4/UART.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC4/UART.c **** *  to call UART_Enable() because the UART_Start() API
 170:.\Generated_Source\PSoC4/UART.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC4/UART.c **** *  operation.
 172:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 6


 173:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 174:.\Generated_Source\PSoC4/UART.c **** *  None.
 175:.\Generated_Source\PSoC4/UART.c **** *
 176:.\Generated_Source\PSoC4/UART.c **** * Return:
 177:.\Generated_Source\PSoC4/UART.c **** *  None.
 178:.\Generated_Source\PSoC4/UART.c **** *
 179:.\Generated_Source\PSoC4/UART.c **** * Global Variables:
 180:.\Generated_Source\PSoC4/UART.c **** *  UART_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC4/UART.c **** *
 182:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC4/UART.c **** void UART_Enable(void) 
 184:.\Generated_Source\PSoC4/UART.c **** {
 114              		.loc 1 184 0
 115              		.cfi_startproc
 116 0000 90B5     		push	{r4, r7, lr}
 117              		.cfi_def_cfa_offset 12
 118              		.cfi_offset 4, -12
 119              		.cfi_offset 7, -8
 120              		.cfi_offset 14, -4
 121 0002 83B0     		sub	sp, sp, #12
 122              		.cfi_def_cfa_offset 24
 123 0004 00AF     		add	r7, sp, #0
 124              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC4/UART.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC4/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 125              		.loc 1 186 0
 126 0006 FC1D     		add	r4, r7, #7
 127 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 128 000c 031C     		mov	r3, r0
 129 000e 2370     		strb	r3, [r4]
 187:.\Generated_Source\PSoC4/UART.c **** 
 188:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 189:.\Generated_Source\PSoC4/UART.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 191:.\Generated_Source\PSoC4/UART.c **** 
 192:.\Generated_Source\PSoC4/UART.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_ACTL_REG  |= UART_INT_ENABLE;
 194:.\Generated_Source\PSoC4/UART.c **** 
 195:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC4/UART.c ****             UART_EnableRxInt();
 197:.\Generated_Source\PSoC4/UART.c **** 
 198:.\Generated_Source\PSoC4/UART.c ****             #if (UART_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC4/UART.c ****                 UART_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC4/UART.c ****             #endif /* (UART_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 203:.\Generated_Source\PSoC4/UART.c **** 
 204:.\Generated_Source\PSoC4/UART.c ****     #if(UART_TX_ENABLED)
 205:.\Generated_Source\PSoC4/UART.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC4/UART.c ****         #if(!UART_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 208:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC4/UART.c **** 
 210:.\Generated_Source\PSoC4/UART.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_ACTL_REG |= UART_INT_ENABLE;
 130              		.loc 1 211 0
 131 0010 084B     		ldr	r3, .L9
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 7


 132 0012 084A     		ldr	r2, .L9
 133 0014 1278     		ldrb	r2, [r2]
 134 0016 D2B2     		uxtb	r2, r2
 135 0018 1021     		mov	r1, #16
 136 001a 0A43     		orr	r2, r1
 137 001c D2B2     		uxtb	r2, r2
 138 001e 1A70     		strb	r2, [r3]
 212:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC4/UART.c ****             UART_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
 215:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC4/UART.c ****      #endif /* (UART_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC4/UART.c **** 
 218:.\Generated_Source\PSoC4/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC4/UART.c ****         UART_IntClock_Start();  /* Enable the clock */
 139              		.loc 1 219 0
 140 0020 FFF7FEFF 		bl	UART_IntClock_Start
 220:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC4/UART.c **** 
 222:.\Generated_Source\PSoC4/UART.c ****     CyExitCriticalSection(enableInterrupts);
 141              		.loc 1 222 0
 142 0024 FB1D     		add	r3, r7, #7
 143 0026 1B78     		ldrb	r3, [r3]
 144 0028 181C     		mov	r0, r3
 145 002a FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC4/UART.c **** }
 146              		.loc 1 223 0
 147 002e BD46     		mov	sp, r7
 148 0030 03B0     		add	sp, sp, #12
 149              		@ sp needed
 150 0032 90BD     		pop	{r4, r7, pc}
 151              	.L10:
 152              		.align	2
 153              	.L9:
 154 0034 93000F40 		.word	1074725011
 155              		.cfi_endproc
 156              	.LFE2:
 157              		.size	UART_Enable, .-UART_Enable
 158              		.section	.text.UART_Stop,"ax",%progbits
 159              		.align	2
 160              		.global	UART_Stop
 161              		.code	16
 162              		.thumb_func
 163              		.type	UART_Stop, %function
 164              	UART_Stop:
 165              	.LFB3:
 224:.\Generated_Source\PSoC4/UART.c **** 
 225:.\Generated_Source\PSoC4/UART.c **** 
 226:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Stop
 228:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 229:.\Generated_Source\PSoC4/UART.c **** *
 230:.\Generated_Source\PSoC4/UART.c **** * Summary:
 231:.\Generated_Source\PSoC4/UART.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC4/UART.c **** *
 233:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 234:.\Generated_Source\PSoC4/UART.c **** *  None.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 8


 235:.\Generated_Source\PSoC4/UART.c **** *
 236:.\Generated_Source\PSoC4/UART.c **** * Return:
 237:.\Generated_Source\PSoC4/UART.c **** *  None.
 238:.\Generated_Source\PSoC4/UART.c **** *
 239:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC4/UART.c **** void UART_Stop(void) 
 241:.\Generated_Source\PSoC4/UART.c **** {
 166              		.loc 1 241 0
 167              		.cfi_startproc
 168 0000 90B5     		push	{r4, r7, lr}
 169              		.cfi_def_cfa_offset 12
 170              		.cfi_offset 4, -12
 171              		.cfi_offset 7, -8
 172              		.cfi_offset 14, -4
 173 0002 83B0     		sub	sp, sp, #12
 174              		.cfi_def_cfa_offset 24
 175 0004 00AF     		add	r7, sp, #0
 176              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC4/UART.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC4/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 177              		.loc 1 243 0
 178 0006 FC1D     		add	r4, r7, #7
 179 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 180 000c 031C     		mov	r3, r0
 181 000e 2370     		strb	r3, [r4]
 244:.\Generated_Source\PSoC4/UART.c **** 
 245:.\Generated_Source\PSoC4/UART.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 247:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 248:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 249:.\Generated_Source\PSoC4/UART.c **** 
 250:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_ENABLED)
 251:.\Generated_Source\PSoC4/UART.c ****         #if(!UART_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 253:.\Generated_Source\PSoC4/UART.c ****         #endif /* (!UART_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_ENABLED) */
 255:.\Generated_Source\PSoC4/UART.c **** 
 256:.\Generated_Source\PSoC4/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC4/UART.c ****         UART_IntClock_Stop();   /* Disable the clock */
 182              		.loc 1 257 0
 183 0010 FFF7FEFF 		bl	UART_IntClock_Stop
 258:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC4/UART.c **** 
 260:.\Generated_Source\PSoC4/UART.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 262:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_ACTL_REG  &= (uint8) ~UART_INT_ENABLE;
 263:.\Generated_Source\PSoC4/UART.c **** 
 264:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC4/UART.c ****             UART_DisableRxInt();
 266:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 268:.\Generated_Source\PSoC4/UART.c **** 
 269:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_ENABLED)
 270:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_ACTL_REG &= (uint8) ~UART_INT_ENABLE;
 184              		.loc 1 270 0
 185 0014 074B     		ldr	r3, .L12
 186 0016 074A     		ldr	r2, .L12
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 9


 187 0018 1278     		ldrb	r2, [r2]
 188 001a D2B2     		uxtb	r2, r2
 189 001c 1021     		mov	r1, #16
 190 001e 8A43     		bic	r2, r1
 191 0020 D2B2     		uxtb	r2, r2
 192 0022 1A70     		strb	r2, [r3]
 271:.\Generated_Source\PSoC4/UART.c **** 
 272:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
 274:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_ENABLED) */
 276:.\Generated_Source\PSoC4/UART.c **** 
 277:.\Generated_Source\PSoC4/UART.c ****     CyExitCriticalSection(enableInterrupts);
 193              		.loc 1 277 0
 194 0024 FB1D     		add	r3, r7, #7
 195 0026 1B78     		ldrb	r3, [r3]
 196 0028 181C     		mov	r0, r3
 197 002a FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC4/UART.c **** }
 198              		.loc 1 278 0
 199 002e BD46     		mov	sp, r7
 200 0030 03B0     		add	sp, sp, #12
 201              		@ sp needed
 202 0032 90BD     		pop	{r4, r7, pc}
 203              	.L13:
 204              		.align	2
 205              	.L12:
 206 0034 93000F40 		.word	1074725011
 207              		.cfi_endproc
 208              	.LFE3:
 209              		.size	UART_Stop, .-UART_Stop
 210              		.section	.text.UART_ReadControlRegister,"ax",%progbits
 211              		.align	2
 212              		.global	UART_ReadControlRegister
 213              		.code	16
 214              		.thumb_func
 215              		.type	UART_ReadControlRegister, %function
 216              	UART_ReadControlRegister:
 217              	.LFB4:
 279:.\Generated_Source\PSoC4/UART.c **** 
 280:.\Generated_Source\PSoC4/UART.c **** 
 281:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_ReadControlRegister
 283:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 284:.\Generated_Source\PSoC4/UART.c **** *
 285:.\Generated_Source\PSoC4/UART.c **** * Summary:
 286:.\Generated_Source\PSoC4/UART.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC4/UART.c **** *
 288:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 289:.\Generated_Source\PSoC4/UART.c **** *  None.
 290:.\Generated_Source\PSoC4/UART.c **** *
 291:.\Generated_Source\PSoC4/UART.c **** * Return:
 292:.\Generated_Source\PSoC4/UART.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC4/UART.c **** *
 294:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC4/UART.c **** uint8 UART_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC4/UART.c **** {
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 10


 218              		.loc 1 296 0
 219              		.cfi_startproc
 220 0000 80B5     		push	{r7, lr}
 221              		.cfi_def_cfa_offset 8
 222              		.cfi_offset 7, -8
 223              		.cfi_offset 14, -4
 224 0002 00AF     		add	r7, sp, #0
 225              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC4/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC4/UART.c ****         return(0u);
 226              		.loc 1 298 0
 227 0004 0023     		mov	r3, #0
 299:.\Generated_Source\PSoC4/UART.c ****     #else
 300:.\Generated_Source\PSoC4/UART.c ****         return(UART_CONTROL_REG);
 301:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC4/UART.c **** }
 228              		.loc 1 302 0
 229 0006 181C     		mov	r0, r3
 230 0008 BD46     		mov	sp, r7
 231              		@ sp needed
 232 000a 80BD     		pop	{r7, pc}
 233              		.cfi_endproc
 234              	.LFE4:
 235              		.size	UART_ReadControlRegister, .-UART_ReadControlRegister
 236              		.section	.text.UART_WriteControlRegister,"ax",%progbits
 237              		.align	2
 238              		.global	UART_WriteControlRegister
 239              		.code	16
 240              		.thumb_func
 241              		.type	UART_WriteControlRegister, %function
 242              	UART_WriteControlRegister:
 243              	.LFB5:
 303:.\Generated_Source\PSoC4/UART.c **** 
 304:.\Generated_Source\PSoC4/UART.c **** 
 305:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_WriteControlRegister
 307:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 308:.\Generated_Source\PSoC4/UART.c **** *
 309:.\Generated_Source\PSoC4/UART.c **** * Summary:
 310:.\Generated_Source\PSoC4/UART.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC4/UART.c **** *
 312:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 313:.\Generated_Source\PSoC4/UART.c **** *  control:  control register value
 314:.\Generated_Source\PSoC4/UART.c **** *
 315:.\Generated_Source\PSoC4/UART.c **** * Return:
 316:.\Generated_Source\PSoC4/UART.c **** *  None.
 317:.\Generated_Source\PSoC4/UART.c **** *
 318:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC4/UART.c **** void  UART_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC4/UART.c **** {
 244              		.loc 1 320 0
 245              		.cfi_startproc
 246 0000 80B5     		push	{r7, lr}
 247              		.cfi_def_cfa_offset 8
 248              		.cfi_offset 7, -8
 249              		.cfi_offset 14, -4
 250 0002 82B0     		sub	sp, sp, #8
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 11


 251              		.cfi_def_cfa_offset 16
 252 0004 00AF     		add	r7, sp, #0
 253              		.cfi_def_cfa_register 7
 254 0006 021C     		mov	r2, r0
 255 0008 FB1D     		add	r3, r7, #7
 256 000a 1A70     		strb	r2, [r3]
 321:.\Generated_Source\PSoC4/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC4/UART.c ****         if(0u != control)
 323:.\Generated_Source\PSoC4/UART.c ****         {
 324:.\Generated_Source\PSoC4/UART.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC4/UART.c ****         }
 326:.\Generated_Source\PSoC4/UART.c ****     #else
 327:.\Generated_Source\PSoC4/UART.c ****        UART_CONTROL_REG = control;
 328:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC4/UART.c **** }
 257              		.loc 1 329 0
 258 000c BD46     		mov	sp, r7
 259 000e 02B0     		add	sp, sp, #8
 260              		@ sp needed
 261 0010 80BD     		pop	{r7, pc}
 262              		.cfi_endproc
 263              	.LFE5:
 264              		.size	UART_WriteControlRegister, .-UART_WriteControlRegister
 265 0012 C046     		.section	.text.UART_SetTxInterruptMode,"ax",%progbits
 266              		.align	2
 267              		.global	UART_SetTxInterruptMode
 268              		.code	16
 269              		.thumb_func
 270              		.type	UART_SetTxInterruptMode, %function
 271              	UART_SetTxInterruptMode:
 272              	.LFB6:
 330:.\Generated_Source\PSoC4/UART.c **** 
 331:.\Generated_Source\PSoC4/UART.c **** 
 332:.\Generated_Source\PSoC4/UART.c **** #if(UART_RX_ENABLED || UART_HD_ENABLED)
 333:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxInterruptMode
 335:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC4/UART.c ****     *
 337:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 338:.\Generated_Source\PSoC4/UART.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC4/UART.c ****     *
 340:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 341:.\Generated_Source\PSoC4/UART.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC4/UART.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC4/UART.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC4/UART.c ****     *
 352:.\Generated_Source\PSoC4/UART.c ****     * Return:
 353:.\Generated_Source\PSoC4/UART.c ****     *  None.
 354:.\Generated_Source\PSoC4/UART.c ****     *
 355:.\Generated_Source\PSoC4/UART.c ****     * Theory:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 12


 356:.\Generated_Source\PSoC4/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC4/UART.c ****     *
 358:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC4/UART.c ****     {
 361:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_MASK_REG  = intSrc;
 362:.\Generated_Source\PSoC4/UART.c ****     }
 363:.\Generated_Source\PSoC4/UART.c **** 
 364:.\Generated_Source\PSoC4/UART.c **** 
 365:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadRxData
 367:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC4/UART.c ****     *
 369:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 370:.\Generated_Source\PSoC4/UART.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC4/UART.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC4/UART.c ****     *
 373:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 374:.\Generated_Source\PSoC4/UART.c ****     *  None.
 375:.\Generated_Source\PSoC4/UART.c ****     *
 376:.\Generated_Source\PSoC4/UART.c ****     * Return:
 377:.\Generated_Source\PSoC4/UART.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC4/UART.c ****     *
 379:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 380:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC4/UART.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC4/UART.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC4/UART.c ****     *
 388:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 389:.\Generated_Source\PSoC4/UART.c ****     *  No.
 390:.\Generated_Source\PSoC4/UART.c ****     *
 391:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadRxData(void) 
 393:.\Generated_Source\PSoC4/UART.c ****     {
 394:.\Generated_Source\PSoC4/UART.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC4/UART.c **** 
 396:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC4/UART.c **** 
 398:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC4/UART.c **** 
 401:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 403:.\Generated_Source\PSoC4/UART.c **** 
 404:.\Generated_Source\PSoC4/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 405:.\Generated_Source\PSoC4/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 406:.\Generated_Source\PSoC4/UART.c **** 
 407:.\Generated_Source\PSoC4/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:.\Generated_Source\PSoC4/UART.c ****         {
 409:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC4/UART.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC4/UART.c **** 
 412:.\Generated_Source\PSoC4/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 13


 413:.\Generated_Source\PSoC4/UART.c ****             {
 414:.\Generated_Source\PSoC4/UART.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC4/UART.c ****             }
 416:.\Generated_Source\PSoC4/UART.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC4/UART.c **** 
 419:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC4/UART.c ****             {
 421:.\Generated_Source\PSoC4/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC4/UART.c ****                 #if ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC4/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC4/UART.c ****                     #if( UART_HD_ENABLED )
 425:.\Generated_Source\PSoC4/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC4/UART.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC4/UART.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC4/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC4/UART.c ****                             */
 430:.\Generated_Source\PSoC4/UART.c ****                             UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC4/UART.c ****                         }
 432:.\Generated_Source\PSoC4/UART.c ****                     #else
 433:.\Generated_Source\PSoC4/UART.c ****                         UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC4/UART.c ****                     #endif /* end UART_HD_ENABLED */
 435:.\Generated_Source\PSoC4/UART.c ****                 #endif /* ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC4/UART.c ****             }
 437:.\Generated_Source\PSoC4/UART.c ****         }
 438:.\Generated_Source\PSoC4/UART.c ****         else
 439:.\Generated_Source\PSoC4/UART.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_RXDATA_REG;
 441:.\Generated_Source\PSoC4/UART.c ****         }
 442:.\Generated_Source\PSoC4/UART.c **** 
 443:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 444:.\Generated_Source\PSoC4/UART.c **** 
 445:.\Generated_Source\PSoC4/UART.c ****     #else
 446:.\Generated_Source\PSoC4/UART.c **** 
 447:.\Generated_Source\PSoC4/UART.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC4/UART.c ****         rxData = UART_RXDATA_REG;
 449:.\Generated_Source\PSoC4/UART.c **** 
 450:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC4/UART.c **** 
 452:.\Generated_Source\PSoC4/UART.c ****         return(rxData);
 453:.\Generated_Source\PSoC4/UART.c ****     }
 454:.\Generated_Source\PSoC4/UART.c **** 
 455:.\Generated_Source\PSoC4/UART.c **** 
 456:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadRxStatus
 458:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC4/UART.c ****     *
 460:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 461:.\Generated_Source\PSoC4/UART.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC4/UART.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC4/UART.c ****     *
 464:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 465:.\Generated_Source\PSoC4/UART.c ****     *  None.
 466:.\Generated_Source\PSoC4/UART.c ****     *
 467:.\Generated_Source\PSoC4/UART.c ****     * Return:
 468:.\Generated_Source\PSoC4/UART.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 14


 470:.\Generated_Source\PSoC4/UART.c ****     * Side Effect:
 471:.\Generated_Source\PSoC4/UART.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC4/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC4/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC4/UART.c ****     *  register read.
 475:.\Generated_Source\PSoC4/UART.c ****     *
 476:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 477:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC4/UART.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC4/UART.c ****     *   UART_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC4/UART.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC4/UART.c ****     *   UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC4/UART.c ****     *   bits.
 483:.\Generated_Source\PSoC4/UART.c ****     *
 484:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC4/UART.c ****     {
 487:.\Generated_Source\PSoC4/UART.c ****         uint8 status;
 488:.\Generated_Source\PSoC4/UART.c **** 
 489:.\Generated_Source\PSoC4/UART.c ****         status = UART_RXSTATUS_REG & UART_RX_HW_MASK;
 490:.\Generated_Source\PSoC4/UART.c **** 
 491:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC4/UART.c ****         if(UART_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC4/UART.c ****         {
 494:.\Generated_Source\PSoC4/UART.c ****             status |= UART_RX_STS_SOFT_BUFF_OVER;
 495:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferOverflow = 0u;
 496:.\Generated_Source\PSoC4/UART.c ****         }
 497:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC4/UART.c **** 
 499:.\Generated_Source\PSoC4/UART.c ****         return(status);
 500:.\Generated_Source\PSoC4/UART.c ****     }
 501:.\Generated_Source\PSoC4/UART.c **** 
 502:.\Generated_Source\PSoC4/UART.c **** 
 503:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetChar
 505:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC4/UART.c ****     *
 507:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 508:.\Generated_Source\PSoC4/UART.c ****     *  Returns the last received byte of data. UART_GetChar() is
 509:.\Generated_Source\PSoC4/UART.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC4/UART.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC4/UART.c ****     *
 512:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 513:.\Generated_Source\PSoC4/UART.c ****     *  None.
 514:.\Generated_Source\PSoC4/UART.c ****     *
 515:.\Generated_Source\PSoC4/UART.c ****     * Return:
 516:.\Generated_Source\PSoC4/UART.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC4/UART.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC4/UART.c ****     *
 519:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 520:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC4/UART.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC4/UART.c ****     *     in RX ISR.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 15


 527:.\Generated_Source\PSoC4/UART.c ****     *
 528:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 529:.\Generated_Source\PSoC4/UART.c ****     *  No.
 530:.\Generated_Source\PSoC4/UART.c ****     *
 531:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetChar(void) 
 533:.\Generated_Source\PSoC4/UART.c ****     {
 534:.\Generated_Source\PSoC4/UART.c ****         uint8 rxData = 0u;
 535:.\Generated_Source\PSoC4/UART.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC4/UART.c **** 
 537:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC4/UART.c **** 
 541:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 543:.\Generated_Source\PSoC4/UART.c **** 
 544:.\Generated_Source\PSoC4/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 545:.\Generated_Source\PSoC4/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 546:.\Generated_Source\PSoC4/UART.c **** 
 547:.\Generated_Source\PSoC4/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC4/UART.c ****         {
 549:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC4/UART.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC4/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC4/UART.c ****             {
 553:.\Generated_Source\PSoC4/UART.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC4/UART.c ****             }
 555:.\Generated_Source\PSoC4/UART.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC4/UART.c **** 
 558:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC4/UART.c ****             {
 560:.\Generated_Source\PSoC4/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC4/UART.c ****                 #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC4/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC4/UART.c ****                     #if( UART_HD_ENABLED )
 564:.\Generated_Source\PSoC4/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC4/UART.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC4/UART.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC4/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC4/UART.c ****                             */
 569:.\Generated_Source\PSoC4/UART.c ****                             UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC4/UART.c ****                         }
 571:.\Generated_Source\PSoC4/UART.c ****                     #else
 572:.\Generated_Source\PSoC4/UART.c ****                         UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC4/UART.c ****                     #endif /* end UART_HD_ENABLED */
 574:.\Generated_Source\PSoC4/UART.c ****                 #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC4/UART.c ****             }
 576:.\Generated_Source\PSoC4/UART.c **** 
 577:.\Generated_Source\PSoC4/UART.c ****         }
 578:.\Generated_Source\PSoC4/UART.c ****         else
 579:.\Generated_Source\PSoC4/UART.c ****         {   rxStatus = UART_RXSTATUS_REG;
 580:.\Generated_Source\PSoC4/UART.c ****             if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC4/UART.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC4/UART.c ****                 rxData = UART_RXDATA_REG;
 583:.\Generated_Source\PSoC4/UART.c ****                 /*Check status on error*/
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 16


 584:.\Generated_Source\PSoC4/UART.c ****                 if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC4/UART.c ****                                 UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC4/UART.c ****                 {
 587:.\Generated_Source\PSoC4/UART.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC4/UART.c ****                 }
 589:.\Generated_Source\PSoC4/UART.c ****             }
 590:.\Generated_Source\PSoC4/UART.c ****         }
 591:.\Generated_Source\PSoC4/UART.c **** 
 592:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 593:.\Generated_Source\PSoC4/UART.c **** 
 594:.\Generated_Source\PSoC4/UART.c ****     #else
 595:.\Generated_Source\PSoC4/UART.c **** 
 596:.\Generated_Source\PSoC4/UART.c ****         rxStatus =UART_RXSTATUS_REG;
 597:.\Generated_Source\PSoC4/UART.c ****         if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 598:.\Generated_Source\PSoC4/UART.c ****         {
 599:.\Generated_Source\PSoC4/UART.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_RXDATA_REG;
 601:.\Generated_Source\PSoC4/UART.c **** 
 602:.\Generated_Source\PSoC4/UART.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC4/UART.c ****             if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC4/UART.c ****                             UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 605:.\Generated_Source\PSoC4/UART.c ****             {
 606:.\Generated_Source\PSoC4/UART.c ****                 rxData = 0u;
 607:.\Generated_Source\PSoC4/UART.c ****             }
 608:.\Generated_Source\PSoC4/UART.c ****         }
 609:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC4/UART.c **** 
 611:.\Generated_Source\PSoC4/UART.c ****         return(rxData);
 612:.\Generated_Source\PSoC4/UART.c ****     }
 613:.\Generated_Source\PSoC4/UART.c **** 
 614:.\Generated_Source\PSoC4/UART.c **** 
 615:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetByte
 617:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC4/UART.c ****     *
 619:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 620:.\Generated_Source\PSoC4/UART.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC4/UART.c ****     *  condition.
 622:.\Generated_Source\PSoC4/UART.c ****     *
 623:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 624:.\Generated_Source\PSoC4/UART.c ****     *  None.
 625:.\Generated_Source\PSoC4/UART.c ****     *
 626:.\Generated_Source\PSoC4/UART.c ****     * Return:
 627:.\Generated_Source\PSoC4/UART.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC4/UART.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC4/UART.c ****     *
 630:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 631:.\Generated_Source\PSoC4/UART.c ****     *  No.
 632:.\Generated_Source\PSoC4/UART.c ****     *
 633:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC4/UART.c ****     uint16 UART_GetByte(void) 
 635:.\Generated_Source\PSoC4/UART.c ****     {
 636:.\Generated_Source\PSoC4/UART.c ****         
 637:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC4/UART.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 17


 641:.\Generated_Source\PSoC4/UART.c ****         locErrorStatus = (uint16)UART_errorStatus;
 642:.\Generated_Source\PSoC4/UART.c ****         UART_errorStatus = 0u;
 643:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 644:.\Generated_Source\PSoC4/UART.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_ReadRxData() );
 645:.\Generated_Source\PSoC4/UART.c ****     #else
 646:.\Generated_Source\PSoC4/UART.c ****         return ( ((uint16)UART_ReadRxStatus() << 8u) | UART_ReadRxData() );
 647:.\Generated_Source\PSoC4/UART.c ****     #endif /* UART_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC4/UART.c ****         
 649:.\Generated_Source\PSoC4/UART.c ****     }
 650:.\Generated_Source\PSoC4/UART.c **** 
 651:.\Generated_Source\PSoC4/UART.c **** 
 652:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetRxBufferSize
 654:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC4/UART.c ****     *
 656:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 657:.\Generated_Source\PSoC4/UART.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC4/UART.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC4/UART.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC4/UART.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC4/UART.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC4/UART.c ****     *    account.
 663:.\Generated_Source\PSoC4/UART.c ****     *
 664:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 665:.\Generated_Source\PSoC4/UART.c ****     *  None.
 666:.\Generated_Source\PSoC4/UART.c ****     *
 667:.\Generated_Source\PSoC4/UART.c ****     * Return:
 668:.\Generated_Source\PSoC4/UART.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC4/UART.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC4/UART.c ****     *
 671:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 672:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC4/UART.c ****     *
 676:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 677:.\Generated_Source\PSoC4/UART.c ****     *  No.
 678:.\Generated_Source\PSoC4/UART.c ****     *
 679:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 680:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC4/UART.c ****     *
 682:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC4/UART.c ****                                                             
 685:.\Generated_Source\PSoC4/UART.c ****     {
 686:.\Generated_Source\PSoC4/UART.c ****         uint8 size;
 687:.\Generated_Source\PSoC4/UART.c **** 
 688:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC4/UART.c **** 
 690:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 692:.\Generated_Source\PSoC4/UART.c **** 
 693:.\Generated_Source\PSoC4/UART.c ****         if(UART_rxBufferRead == UART_rxBufferWrite)
 694:.\Generated_Source\PSoC4/UART.c ****         {
 695:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC4/UART.c ****             {
 697:.\Generated_Source\PSoC4/UART.c ****                 size = UART_RX_BUFFER_SIZE;
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 18


 698:.\Generated_Source\PSoC4/UART.c ****             }
 699:.\Generated_Source\PSoC4/UART.c ****             else
 700:.\Generated_Source\PSoC4/UART.c ****             {
 701:.\Generated_Source\PSoC4/UART.c ****                 size = 0u;
 702:.\Generated_Source\PSoC4/UART.c ****             }
 703:.\Generated_Source\PSoC4/UART.c ****         }
 704:.\Generated_Source\PSoC4/UART.c ****         else if(UART_rxBufferRead < UART_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART.c ****         {
 706:.\Generated_Source\PSoC4/UART.c ****             size = (UART_rxBufferWrite - UART_rxBufferRead);
 707:.\Generated_Source\PSoC4/UART.c ****         }
 708:.\Generated_Source\PSoC4/UART.c ****         else
 709:.\Generated_Source\PSoC4/UART.c ****         {
 710:.\Generated_Source\PSoC4/UART.c ****             size = (UART_RX_BUFFER_SIZE - UART_rxBufferRead) + UART_rxBufferWrite;
 711:.\Generated_Source\PSoC4/UART.c ****         }
 712:.\Generated_Source\PSoC4/UART.c **** 
 713:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 714:.\Generated_Source\PSoC4/UART.c **** 
 715:.\Generated_Source\PSoC4/UART.c ****     #else
 716:.\Generated_Source\PSoC4/UART.c **** 
 717:.\Generated_Source\PSoC4/UART.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC4/UART.c ****         size = ((UART_RXSTATUS_REG & UART_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719:.\Generated_Source\PSoC4/UART.c **** 
 720:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC4/UART.c **** 
 722:.\Generated_Source\PSoC4/UART.c ****         return(size);
 723:.\Generated_Source\PSoC4/UART.c ****     }
 724:.\Generated_Source\PSoC4/UART.c **** 
 725:.\Generated_Source\PSoC4/UART.c **** 
 726:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ClearRxBuffer
 728:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC4/UART.c ****     *
 730:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 731:.\Generated_Source\PSoC4/UART.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC4/UART.c ****     *
 733:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 734:.\Generated_Source\PSoC4/UART.c ****     *  None.
 735:.\Generated_Source\PSoC4/UART.c ****     *
 736:.\Generated_Source\PSoC4/UART.c ****     * Return:
 737:.\Generated_Source\PSoC4/UART.c ****     *  None.
 738:.\Generated_Source\PSoC4/UART.c ****     *
 739:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 740:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC4/UART.c ****     *
 745:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 746:.\Generated_Source\PSoC4/UART.c ****     *  No.
 747:.\Generated_Source\PSoC4/UART.c ****     *
 748:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 749:.\Generated_Source\PSoC4/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC4/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC4/UART.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC4/UART.c ****     *
 753:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
 754:.\Generated_Source\PSoC4/UART.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 19


 755:.\Generated_Source\PSoC4/UART.c ****     *
 756:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC4/UART.c ****     void UART_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC4/UART.c ****     {
 759:.\Generated_Source\PSoC4/UART.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC4/UART.c **** 
 761:.\Generated_Source\PSoC4/UART.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC4/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 763:.\Generated_Source\PSoC4/UART.c ****         UART_RXDATA_AUX_CTL_REG |= (uint8)  UART_RX_FIFO_CLR;
 764:.\Generated_Source\PSoC4/UART.c ****         UART_RXDATA_AUX_CTL_REG &= (uint8) ~UART_RX_FIFO_CLR;
 765:.\Generated_Source\PSoC4/UART.c ****         CyExitCriticalSection(enableInterrupts);
 766:.\Generated_Source\PSoC4/UART.c **** 
 767:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC4/UART.c **** 
 769:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 771:.\Generated_Source\PSoC4/UART.c **** 
 772:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC4/UART.c **** 
 777:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 778:.\Generated_Source\PSoC4/UART.c **** 
 779:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC4/UART.c **** 
 781:.\Generated_Source\PSoC4/UART.c ****     }
 782:.\Generated_Source\PSoC4/UART.c **** 
 783:.\Generated_Source\PSoC4/UART.c **** 
 784:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddressMode
 786:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC4/UART.c ****     *
 788:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 789:.\Generated_Source\PSoC4/UART.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC4/UART.c ****     *  UART.
 791:.\Generated_Source\PSoC4/UART.c ****     *
 792:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 793:.\Generated_Source\PSoC4/UART.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC4/UART.c ****     *                                               detection
 796:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC4/UART.c ****     *                                               address detection
 798:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC4/UART.c ****     *                                               detection
 800:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC4/UART.c ****     *                                               address detection
 802:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC4/UART.c ****     *
 804:.\Generated_Source\PSoC4/UART.c ****     * Return:
 805:.\Generated_Source\PSoC4/UART.c ****     *  None.
 806:.\Generated_Source\PSoC4/UART.c ****     *
 807:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 808:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC4/UART.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 20


 812:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC4/UART.c ****                                                         
 815:.\Generated_Source\PSoC4/UART.c ****     {
 816:.\Generated_Source\PSoC4/UART.c ****         #if(UART_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC4/UART.c ****             #if(UART_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC4/UART.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC4/UART.c ****                 {
 820:.\Generated_Source\PSoC4/UART.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC4/UART.c ****                 }
 822:.\Generated_Source\PSoC4/UART.c ****             #else /* UART_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC4/UART.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC4/UART.c ****                 tmpCtrl = UART_CONTROL_REG & (uint8)~UART_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC4/UART.c ****                 tmpCtrl |= (uint8)(addressMode << UART_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC4/UART.c ****                 UART_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC4/UART.c **** 
 828:.\Generated_Source\PSoC4/UART.c ****                 #if(UART_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC4/UART.c ****                    (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC4/UART.c ****                     UART_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC4/UART.c ****                     UART_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC4/UART.c ****         #else /* UART_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC4/UART.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC4/UART.c ****             {
 837:.\Generated_Source\PSoC4/UART.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC4/UART.c ****             }
 839:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC4/UART.c ****     }
 841:.\Generated_Source\PSoC4/UART.c **** 
 842:.\Generated_Source\PSoC4/UART.c **** 
 843:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddress1
 845:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC4/UART.c ****     *
 847:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 848:.\Generated_Source\PSoC4/UART.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC4/UART.c ****     *
 850:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 851:.\Generated_Source\PSoC4/UART.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC4/UART.c ****     *
 853:.\Generated_Source\PSoC4/UART.c ****     * Return:
 854:.\Generated_Source\PSoC4/UART.c ****     *  None.
 855:.\Generated_Source\PSoC4/UART.c ****     *
 856:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC4/UART.c ****     {
 859:.\Generated_Source\PSoC4/UART.c ****         UART_RXADDRESS1_REG = address;
 860:.\Generated_Source\PSoC4/UART.c ****     }
 861:.\Generated_Source\PSoC4/UART.c **** 
 862:.\Generated_Source\PSoC4/UART.c **** 
 863:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddress2
 865:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC4/UART.c ****     *
 867:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 868:.\Generated_Source\PSoC4/UART.c ****     *  Sets the second of two hardware-detectable receiver addresses.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 21


 869:.\Generated_Source\PSoC4/UART.c ****     *
 870:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 871:.\Generated_Source\PSoC4/UART.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC4/UART.c ****     *
 873:.\Generated_Source\PSoC4/UART.c ****     * Return:
 874:.\Generated_Source\PSoC4/UART.c ****     *  None.
 875:.\Generated_Source\PSoC4/UART.c ****     *
 876:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC4/UART.c ****     {
 879:.\Generated_Source\PSoC4/UART.c ****         UART_RXADDRESS2_REG = address;
 880:.\Generated_Source\PSoC4/UART.c ****     }
 881:.\Generated_Source\PSoC4/UART.c **** 
 882:.\Generated_Source\PSoC4/UART.c **** #endif  /* UART_RX_ENABLED || UART_HD_ENABLED*/
 883:.\Generated_Source\PSoC4/UART.c **** 
 884:.\Generated_Source\PSoC4/UART.c **** 
 885:.\Generated_Source\PSoC4/UART.c **** #if( (UART_TX_ENABLED) || (UART_HD_ENABLED) )
 886:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetTxInterruptMode
 888:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC4/UART.c ****     *
 890:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 891:.\Generated_Source\PSoC4/UART.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC4/UART.c ****     *  interrupt.
 893:.\Generated_Source\PSoC4/UART.c ****     *
 894:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 895:.\Generated_Source\PSoC4/UART.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC4/UART.c ****     *
 901:.\Generated_Source\PSoC4/UART.c ****     * Return:
 902:.\Generated_Source\PSoC4/UART.c ****     *  None.
 903:.\Generated_Source\PSoC4/UART.c ****     *
 904:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 905:.\Generated_Source\PSoC4/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC4/UART.c ****     *
 907:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC4/UART.c ****     void UART_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC4/UART.c ****     {
 273              		.loc 1 909 0
 274              		.cfi_startproc
 275 0000 80B5     		push	{r7, lr}
 276              		.cfi_def_cfa_offset 8
 277              		.cfi_offset 7, -8
 278              		.cfi_offset 14, -4
 279 0002 82B0     		sub	sp, sp, #8
 280              		.cfi_def_cfa_offset 16
 281 0004 00AF     		add	r7, sp, #0
 282              		.cfi_def_cfa_register 7
 283 0006 021C     		mov	r2, r0
 284 0008 FB1D     		add	r3, r7, #7
 285 000a 1A70     		strb	r2, [r3]
 910:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_MASK_REG = intSrc;
 286              		.loc 1 910 0
 287 000c 034B     		ldr	r3, .L18
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 22


 288 000e FA1D     		add	r2, r7, #7
 289 0010 1278     		ldrb	r2, [r2]
 290 0012 1A70     		strb	r2, [r3]
 911:.\Generated_Source\PSoC4/UART.c ****     }
 291              		.loc 1 911 0
 292 0014 BD46     		mov	sp, r7
 293 0016 02B0     		add	sp, sp, #8
 294              		@ sp needed
 295 0018 80BD     		pop	{r7, pc}
 296              	.L19:
 297 001a C046     		.align	2
 298              	.L18:
 299 001c 83000F40 		.word	1074724995
 300              		.cfi_endproc
 301              	.LFE6:
 302              		.size	UART_SetTxInterruptMode, .-UART_SetTxInterruptMode
 303              		.section	.text.UART_WriteTxData,"ax",%progbits
 304              		.align	2
 305              		.global	UART_WriteTxData
 306              		.code	16
 307              		.thumb_func
 308              		.type	UART_WriteTxData, %function
 309              	UART_WriteTxData:
 310              	.LFB7:
 912:.\Generated_Source\PSoC4/UART.c **** 
 913:.\Generated_Source\PSoC4/UART.c **** 
 914:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_WriteTxData
 916:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC4/UART.c ****     *
 918:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 919:.\Generated_Source\PSoC4/UART.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC4/UART.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC4/UART.c ****     *  separately.
 922:.\Generated_Source\PSoC4/UART.c ****     *
 923:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 924:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC4/UART.c ****     *
 926:.\Generated_Source\PSoC4/UART.c ****     * Return:
 927:.\Generated_Source\PSoC4/UART.c ****     * None.
 928:.\Generated_Source\PSoC4/UART.c ****     *
 929:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 930:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC4/UART.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC4/UART.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC4/UART.c ****     *    initialized.
 937:.\Generated_Source\PSoC4/UART.c ****     *
 938:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 939:.\Generated_Source\PSoC4/UART.c ****     *  No.
 940:.\Generated_Source\PSoC4/UART.c ****     *
 941:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART.c ****     void UART_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC4/UART.c ****     {
 311              		.loc 1 943 0
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 23


 312              		.cfi_startproc
 313 0000 80B5     		push	{r7, lr}
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 7, -8
 316              		.cfi_offset 14, -4
 317 0002 82B0     		sub	sp, sp, #8
 318              		.cfi_def_cfa_offset 16
 319 0004 00AF     		add	r7, sp, #0
 320              		.cfi_def_cfa_register 7
 321 0006 021C     		mov	r2, r0
 322 0008 FB1D     		add	r3, r7, #7
 323 000a 1A70     		strb	r2, [r3]
 944:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 324              		.loc 1 945 0
 325 000c 054B     		ldr	r3, .L22
 326 000e 1B78     		ldrb	r3, [r3]
 327 0010 002B     		cmp	r3, #0
 328 0012 03D0     		beq	.L20
 946:.\Generated_Source\PSoC4/UART.c ****         {
 947:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC4/UART.c **** 
 949:.\Generated_Source\PSoC4/UART.c ****             /* Protect variables that could change on interrupt. */
 950:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
 951:.\Generated_Source\PSoC4/UART.c **** 
 952:.\Generated_Source\PSoC4/UART.c ****             if( (UART_txBufferRead == UART_txBufferWrite) &&
 953:.\Generated_Source\PSoC4/UART.c ****                 ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC4/UART.c ****             {
 955:.\Generated_Source\PSoC4/UART.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC4/UART.c ****             }
 958:.\Generated_Source\PSoC4/UART.c ****             else
 959:.\Generated_Source\PSoC4/UART.c ****             {
 960:.\Generated_Source\PSoC4/UART.c ****                 if(UART_txBufferWrite >= UART_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC4/UART.c ****                 {
 962:.\Generated_Source\PSoC4/UART.c ****                     UART_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC4/UART.c ****                 }
 964:.\Generated_Source\PSoC4/UART.c **** 
 965:.\Generated_Source\PSoC4/UART.c ****                 UART_txBuffer[UART_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC4/UART.c **** 
 967:.\Generated_Source\PSoC4/UART.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC4/UART.c ****                 UART_txBufferWrite++;
 969:.\Generated_Source\PSoC4/UART.c ****             }
 970:.\Generated_Source\PSoC4/UART.c **** 
 971:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
 972:.\Generated_Source\PSoC4/UART.c **** 
 973:.\Generated_Source\PSoC4/UART.c ****         #else
 974:.\Generated_Source\PSoC4/UART.c **** 
 975:.\Generated_Source\PSoC4/UART.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC4/UART.c ****             UART_TXDATA_REG = txDataByte;
 329              		.loc 1 976 0
 330 0014 044B     		ldr	r3, .L22+4
 331 0016 FA1D     		add	r2, r7, #7
 332 0018 1278     		ldrb	r2, [r2]
 333 001a 1A70     		strb	r2, [r3]
 334              	.L20:
 977:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 24


 978:.\Generated_Source\PSoC4/UART.c ****         #endif /*(UART_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC4/UART.c ****         }
 980:.\Generated_Source\PSoC4/UART.c ****     }
 335              		.loc 1 980 0
 336 001c BD46     		mov	sp, r7
 337 001e 02B0     		add	sp, sp, #8
 338              		@ sp needed
 339 0020 80BD     		pop	{r7, pc}
 340              	.L23:
 341 0022 C046     		.align	2
 342              	.L22:
 343 0024 00000000 		.word	UART_initVar
 344 0028 43000F40 		.word	1074724931
 345              		.cfi_endproc
 346              	.LFE7:
 347              		.size	UART_WriteTxData, .-UART_WriteTxData
 348              		.section	.text.UART_ReadTxStatus,"ax",%progbits
 349              		.align	2
 350              		.global	UART_ReadTxStatus
 351              		.code	16
 352              		.thumb_func
 353              		.type	UART_ReadTxStatus, %function
 354              	UART_ReadTxStatus:
 355              	.LFB8:
 981:.\Generated_Source\PSoC4/UART.c **** 
 982:.\Generated_Source\PSoC4/UART.c **** 
 983:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadTxStatus
 985:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC4/UART.c ****     *
 987:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 988:.\Generated_Source\PSoC4/UART.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC4/UART.c ****     *
 990:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 991:.\Generated_Source\PSoC4/UART.c ****     *  None.
 992:.\Generated_Source\PSoC4/UART.c ****     *
 993:.\Generated_Source\PSoC4/UART.c ****     * Return:
 994:.\Generated_Source\PSoC4/UART.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC4/UART.c ****     *
 996:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 997:.\Generated_Source\PSoC4/UART.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC4/UART.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC4/UART.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC4/UART.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC4/UART.c ****     *
1002:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC4/UART.c ****     {
 356              		.loc 1 1004 0
 357              		.cfi_startproc
 358 0000 80B5     		push	{r7, lr}
 359              		.cfi_def_cfa_offset 8
 360              		.cfi_offset 7, -8
 361              		.cfi_offset 14, -4
 362 0002 00AF     		add	r7, sp, #0
 363              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC4/UART.c ****         return(UART_TXSTATUS_REG);
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 25


 364              		.loc 1 1005 0
 365 0004 024B     		ldr	r3, .L26
 366 0006 1B78     		ldrb	r3, [r3]
 367 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC4/UART.c ****     }
 368              		.loc 1 1006 0
 369 000a 181C     		mov	r0, r3
 370 000c BD46     		mov	sp, r7
 371              		@ sp needed
 372 000e 80BD     		pop	{r7, pc}
 373              	.L27:
 374              		.align	2
 375              	.L26:
 376 0010 63000F40 		.word	1074724963
 377              		.cfi_endproc
 378              	.LFE8:
 379              		.size	UART_ReadTxStatus, .-UART_ReadTxStatus
 380              		.section	.text.UART_PutChar,"ax",%progbits
 381              		.align	2
 382              		.global	UART_PutChar
 383              		.code	16
 384              		.thumb_func
 385              		.type	UART_PutChar, %function
 386              	UART_PutChar:
 387              	.LFB9:
1007:.\Generated_Source\PSoC4/UART.c **** 
1008:.\Generated_Source\PSoC4/UART.c **** 
1009:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutChar
1011:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC4/UART.c ****     *
1013:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1014:.\Generated_Source\PSoC4/UART.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC4/UART.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC4/UART.c ****     *  hold the data.
1017:.\Generated_Source\PSoC4/UART.c ****     *
1018:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1019:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC4/UART.c ****     *
1021:.\Generated_Source\PSoC4/UART.c ****     * Return:
1022:.\Generated_Source\PSoC4/UART.c ****     *  None.
1023:.\Generated_Source\PSoC4/UART.c ****     *
1024:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1025:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC4/UART.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1033:.\Generated_Source\PSoC4/UART.c ****     *
1034:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1035:.\Generated_Source\PSoC4/UART.c ****     *  No.
1036:.\Generated_Source\PSoC4/UART.c ****     *
1037:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1038:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to transmit any byte of data in a single transfer
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 26


1039:.\Generated_Source\PSoC4/UART.c ****     *
1040:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC4/UART.c ****     void UART_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC4/UART.c ****     {
 388              		.loc 1 1042 0
 389              		.cfi_startproc
 390 0000 80B5     		push	{r7, lr}
 391              		.cfi_def_cfa_offset 8
 392              		.cfi_offset 7, -8
 393              		.cfi_offset 14, -4
 394 0002 82B0     		sub	sp, sp, #8
 395              		.cfi_def_cfa_offset 16
 396 0004 00AF     		add	r7, sp, #0
 397              		.cfi_def_cfa_register 7
 398 0006 021C     		mov	r2, r0
 399 0008 FB1D     		add	r3, r7, #7
 400 000a 1A70     		strb	r2, [r3]
1043:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC4/UART.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC4/UART.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC4/UART.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC4/UART.c ****         */
1048:.\Generated_Source\PSoC4/UART.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC4/UART.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC4/UART.c **** 
1051:.\Generated_Source\PSoC4/UART.c ****         do
1052:.\Generated_Source\PSoC4/UART.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC4/UART.c **** 
1054:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC4/UART.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
1057:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058:.\Generated_Source\PSoC4/UART.c **** 
1059:.\Generated_Source\PSoC4/UART.c ****             locTxBufferWrite = UART_txBufferWrite;
1060:.\Generated_Source\PSoC4/UART.c ****             locTxBufferRead  = UART_txBufferRead;
1061:.\Generated_Source\PSoC4/UART.c **** 
1062:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC4/UART.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
1065:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066:.\Generated_Source\PSoC4/UART.c ****         }
1067:.\Generated_Source\PSoC4/UART.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC4/UART.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC4/UART.c ****                                 (uint8)(UART_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC4/UART.c **** 
1071:.\Generated_Source\PSoC4/UART.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC4/UART.c ****             ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC4/UART.c ****         {
1074:.\Generated_Source\PSoC4/UART.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC4/UART.c ****             UART_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC4/UART.c ****         }
1077:.\Generated_Source\PSoC4/UART.c ****         else
1078:.\Generated_Source\PSoC4/UART.c ****         {
1079:.\Generated_Source\PSoC4/UART.c ****             if(locTxBufferWrite >= UART_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC4/UART.c ****             {
1081:.\Generated_Source\PSoC4/UART.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC4/UART.c ****             }
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 27


1083:.\Generated_Source\PSoC4/UART.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC4/UART.c ****             UART_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC4/UART.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC4/UART.c **** 
1087:.\Generated_Source\PSoC4/UART.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
1090:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091:.\Generated_Source\PSoC4/UART.c **** 
1092:.\Generated_Source\PSoC4/UART.c ****             UART_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC4/UART.c **** 
1094:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
1096:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097:.\Generated_Source\PSoC4/UART.c **** 
1098:.\Generated_Source\PSoC4/UART.c ****             if(0u != (UART_TXSTATUS_REG & UART_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC4/UART.c ****             {
1100:.\Generated_Source\PSoC4/UART.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC4/UART.c ****                 UART_SetPendingTxInt();
1102:.\Generated_Source\PSoC4/UART.c ****             }
1103:.\Generated_Source\PSoC4/UART.c ****         }
1104:.\Generated_Source\PSoC4/UART.c **** 
1105:.\Generated_Source\PSoC4/UART.c ****     #else
1106:.\Generated_Source\PSoC4/UART.c **** 
1107:.\Generated_Source\PSoC4/UART.c ****         while((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) != 0u)
 401              		.loc 1 1107 0
 402 000c C046     		mov	r8, r8
 403              	.L29:
 404              		.loc 1 1107 0 is_stmt 0 discriminator 1
 405 000e 074B     		ldr	r3, .L30
 406 0010 1B78     		ldrb	r3, [r3]
 407 0012 DBB2     		uxtb	r3, r3
 408 0014 1A1C     		mov	r2, r3
 409 0016 0423     		mov	r3, #4
 410 0018 1340     		and	r3, r2
 411 001a F8D1     		bne	.L29
1108:.\Generated_Source\PSoC4/UART.c ****         {
1109:.\Generated_Source\PSoC4/UART.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC4/UART.c ****         }
1111:.\Generated_Source\PSoC4/UART.c **** 
1112:.\Generated_Source\PSoC4/UART.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_REG = txDataByte;
 412              		.loc 1 1113 0 is_stmt 1
 413 001c 044B     		ldr	r3, .L30+4
 414 001e FA1D     		add	r2, r7, #7
 415 0020 1278     		ldrb	r2, [r2]
 416 0022 1A70     		strb	r2, [r3]
1114:.\Generated_Source\PSoC4/UART.c **** 
1115:.\Generated_Source\PSoC4/UART.c ****     #endif /* UART_TX_INTERRUPT_ENABLED */
1116:.\Generated_Source\PSoC4/UART.c ****     }
 417              		.loc 1 1116 0
 418 0024 BD46     		mov	sp, r7
 419 0026 02B0     		add	sp, sp, #8
 420              		@ sp needed
 421 0028 80BD     		pop	{r7, pc}
 422              	.L31:
 423 002a C046     		.align	2
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 28


 424              	.L30:
 425 002c 63000F40 		.word	1074724963
 426 0030 43000F40 		.word	1074724931
 427              		.cfi_endproc
 428              	.LFE9:
 429              		.size	UART_PutChar, .-UART_PutChar
 430              		.section	.text.UART_PutString,"ax",%progbits
 431              		.align	2
 432              		.global	UART_PutString
 433              		.code	16
 434              		.thumb_func
 435              		.type	UART_PutString, %function
 436              	UART_PutString:
 437              	.LFB10:
1117:.\Generated_Source\PSoC4/UART.c **** 
1118:.\Generated_Source\PSoC4/UART.c **** 
1119:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutString
1121:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC4/UART.c ****     *
1123:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1124:.\Generated_Source\PSoC4/UART.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC4/UART.c ****     *
1126:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1127:.\Generated_Source\PSoC4/UART.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC4/UART.c ****     *
1129:.\Generated_Source\PSoC4/UART.c ****     * Return:
1130:.\Generated_Source\PSoC4/UART.c ****     *  None.
1131:.\Generated_Source\PSoC4/UART.c ****     *
1132:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1133:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1135:.\Generated_Source\PSoC4/UART.c ****     *
1136:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1137:.\Generated_Source\PSoC4/UART.c ****     *  No.
1138:.\Generated_Source\PSoC4/UART.c ****     *
1139:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1140:.\Generated_Source\PSoC4/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC4/UART.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC4/UART.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC4/UART.c ****     *
1144:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC4/UART.c ****     void UART_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC4/UART.c ****     {
 438              		.loc 1 1146 0
 439              		.cfi_startproc
 440 0000 80B5     		push	{r7, lr}
 441              		.cfi_def_cfa_offset 8
 442              		.cfi_offset 7, -8
 443              		.cfi_offset 14, -4
 444 0002 84B0     		sub	sp, sp, #16
 445              		.cfi_def_cfa_offset 24
 446 0004 00AF     		add	r7, sp, #0
 447              		.cfi_def_cfa_register 7
 448 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC4/UART.c ****         uint16 bufIndex = 0u;
 449              		.loc 1 1147 0
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 29


 450 0008 3B1C     		mov	r3, r7
 451 000a 0E33     		add	r3, r3, #14
 452 000c 0022     		mov	r2, #0
 453 000e 1A80     		strh	r2, [r3]
1148:.\Generated_Source\PSoC4/UART.c **** 
1149:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 454              		.loc 1 1150 0
 455 0010 0F4B     		ldr	r3, .L36
 456 0012 1B78     		ldrb	r3, [r3]
 457 0014 002B     		cmp	r3, #0
 458 0016 18D0     		beq	.L32
1151:.\Generated_Source\PSoC4/UART.c ****         {
1152:.\Generated_Source\PSoC4/UART.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC4/UART.c ****             while(string[bufIndex] != (char8) 0)
 459              		.loc 1 1153 0
 460 0018 0FE0     		b	.L34
 461              	.L35:
1154:.\Generated_Source\PSoC4/UART.c ****             {
1155:.\Generated_Source\PSoC4/UART.c ****                 UART_PutChar((uint8)string[bufIndex]);
 462              		.loc 1 1155 0
 463 001a 3B1C     		mov	r3, r7
 464 001c 0E33     		add	r3, r3, #14
 465 001e 1B88     		ldrh	r3, [r3]
 466 0020 7A68     		ldr	r2, [r7, #4]
 467 0022 D318     		add	r3, r2, r3
 468 0024 1B78     		ldrb	r3, [r3]
 469 0026 181C     		mov	r0, r3
 470 0028 FFF7FEFF 		bl	UART_PutChar
1156:.\Generated_Source\PSoC4/UART.c ****                 bufIndex++;
 471              		.loc 1 1156 0
 472 002c 3B1C     		mov	r3, r7
 473 002e 0E33     		add	r3, r3, #14
 474 0030 1A88     		ldrh	r2, [r3]
 475 0032 3B1C     		mov	r3, r7
 476 0034 0E33     		add	r3, r3, #14
 477 0036 0132     		add	r2, r2, #1
 478 0038 1A80     		strh	r2, [r3]
 479              	.L34:
1153:.\Generated_Source\PSoC4/UART.c ****             while(string[bufIndex] != (char8) 0)
 480              		.loc 1 1153 0 discriminator 1
 481 003a 3B1C     		mov	r3, r7
 482 003c 0E33     		add	r3, r3, #14
 483 003e 1B88     		ldrh	r3, [r3]
 484 0040 7A68     		ldr	r2, [r7, #4]
 485 0042 D318     		add	r3, r2, r3
 486 0044 1B78     		ldrb	r3, [r3]
 487 0046 002B     		cmp	r3, #0
 488 0048 E7D1     		bne	.L35
 489              	.L32:
1157:.\Generated_Source\PSoC4/UART.c ****             }
1158:.\Generated_Source\PSoC4/UART.c ****         }
1159:.\Generated_Source\PSoC4/UART.c ****     }
 490              		.loc 1 1159 0
 491 004a BD46     		mov	sp, r7
 492 004c 04B0     		add	sp, sp, #16
 493              		@ sp needed
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 30


 494 004e 80BD     		pop	{r7, pc}
 495              	.L37:
 496              		.align	2
 497              	.L36:
 498 0050 00000000 		.word	UART_initVar
 499              		.cfi_endproc
 500              	.LFE10:
 501              		.size	UART_PutString, .-UART_PutString
 502              		.section	.text.UART_PutArray,"ax",%progbits
 503              		.align	2
 504              		.global	UART_PutArray
 505              		.code	16
 506              		.thumb_func
 507              		.type	UART_PutArray, %function
 508              	UART_PutArray:
 509              	.LFB11:
1160:.\Generated_Source\PSoC4/UART.c **** 
1161:.\Generated_Source\PSoC4/UART.c **** 
1162:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutArray
1164:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC4/UART.c ****     *
1166:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1167:.\Generated_Source\PSoC4/UART.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC4/UART.c ****     *  transmission.
1169:.\Generated_Source\PSoC4/UART.c ****     *
1170:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1171:.\Generated_Source\PSoC4/UART.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC4/UART.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC4/UART.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC4/UART.c ****     *
1175:.\Generated_Source\PSoC4/UART.c ****     * Return:
1176:.\Generated_Source\PSoC4/UART.c ****     *  None.
1177:.\Generated_Source\PSoC4/UART.c ****     *
1178:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1179:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1181:.\Generated_Source\PSoC4/UART.c ****     *
1182:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1183:.\Generated_Source\PSoC4/UART.c ****     *  No.
1184:.\Generated_Source\PSoC4/UART.c ****     *
1185:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1186:.\Generated_Source\PSoC4/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC4/UART.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC4/UART.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC4/UART.c ****     *
1190:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC4/UART.c ****     void UART_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC4/UART.c ****                                                                     
1193:.\Generated_Source\PSoC4/UART.c ****     {
 510              		.loc 1 1193 0
 511              		.cfi_startproc
 512 0000 80B5     		push	{r7, lr}
 513              		.cfi_def_cfa_offset 8
 514              		.cfi_offset 7, -8
 515              		.cfi_offset 14, -4
 516 0002 84B0     		sub	sp, sp, #16
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 31


 517              		.cfi_def_cfa_offset 24
 518 0004 00AF     		add	r7, sp, #0
 519              		.cfi_def_cfa_register 7
 520 0006 7860     		str	r0, [r7, #4]
 521 0008 0A1C     		mov	r2, r1
 522 000a FB1C     		add	r3, r7, #3
 523 000c 1A70     		strb	r2, [r3]
1194:.\Generated_Source\PSoC4/UART.c ****         uint8 bufIndex = 0u;
 524              		.loc 1 1194 0
 525 000e 3B1C     		mov	r3, r7
 526 0010 0F33     		add	r3, r3, #15
 527 0012 0022     		mov	r2, #0
 528 0014 1A70     		strb	r2, [r3]
1195:.\Generated_Source\PSoC4/UART.c **** 
1196:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 529              		.loc 1 1197 0
 530 0016 0F4B     		ldr	r3, .L42
 531 0018 1B78     		ldrb	r3, [r3]
 532 001a 002B     		cmp	r3, #0
 533 001c 17D0     		beq	.L38
1198:.\Generated_Source\PSoC4/UART.c ****         {
1199:.\Generated_Source\PSoC4/UART.c ****             while(bufIndex < byteCount)
 534              		.loc 1 1199 0
 535 001e 0FE0     		b	.L40
 536              	.L41:
1200:.\Generated_Source\PSoC4/UART.c ****             {
1201:.\Generated_Source\PSoC4/UART.c ****                 UART_PutChar(string[bufIndex]);
 537              		.loc 1 1201 0
 538 0020 3B1C     		mov	r3, r7
 539 0022 0F33     		add	r3, r3, #15
 540 0024 1B78     		ldrb	r3, [r3]
 541 0026 7A68     		ldr	r2, [r7, #4]
 542 0028 D318     		add	r3, r2, r3
 543 002a 1B78     		ldrb	r3, [r3]
 544 002c 181C     		mov	r0, r3
 545 002e FFF7FEFF 		bl	UART_PutChar
1202:.\Generated_Source\PSoC4/UART.c ****                 bufIndex++;
 546              		.loc 1 1202 0
 547 0032 3B1C     		mov	r3, r7
 548 0034 0F33     		add	r3, r3, #15
 549 0036 1A78     		ldrb	r2, [r3]
 550 0038 3B1C     		mov	r3, r7
 551 003a 0F33     		add	r3, r3, #15
 552 003c 0132     		add	r2, r2, #1
 553 003e 1A70     		strb	r2, [r3]
 554              	.L40:
1199:.\Generated_Source\PSoC4/UART.c ****             while(bufIndex < byteCount)
 555              		.loc 1 1199 0 discriminator 1
 556 0040 3A1C     		mov	r2, r7
 557 0042 0F32     		add	r2, r2, #15
 558 0044 FB1C     		add	r3, r7, #3
 559 0046 1278     		ldrb	r2, [r2]
 560 0048 1B78     		ldrb	r3, [r3]
 561 004a 9A42     		cmp	r2, r3
 562 004c E8D3     		bcc	.L41
 563              	.L38:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 32


1203:.\Generated_Source\PSoC4/UART.c ****             }
1204:.\Generated_Source\PSoC4/UART.c ****         }
1205:.\Generated_Source\PSoC4/UART.c ****     }
 564              		.loc 1 1205 0
 565 004e BD46     		mov	sp, r7
 566 0050 04B0     		add	sp, sp, #16
 567              		@ sp needed
 568 0052 80BD     		pop	{r7, pc}
 569              	.L43:
 570              		.align	2
 571              	.L42:
 572 0054 00000000 		.word	UART_initVar
 573              		.cfi_endproc
 574              	.LFE11:
 575              		.size	UART_PutArray, .-UART_PutArray
 576              		.section	.text.UART_PutCRLF,"ax",%progbits
 577              		.align	2
 578              		.global	UART_PutCRLF
 579              		.code	16
 580              		.thumb_func
 581              		.type	UART_PutCRLF, %function
 582              	UART_PutCRLF:
 583              	.LFB12:
1206:.\Generated_Source\PSoC4/UART.c **** 
1207:.\Generated_Source\PSoC4/UART.c **** 
1208:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutCRLF
1210:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC4/UART.c ****     *
1212:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1213:.\Generated_Source\PSoC4/UART.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC4/UART.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC4/UART.c ****     *
1216:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1217:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC4/UART.c ****     *
1219:.\Generated_Source\PSoC4/UART.c ****     * Return:
1220:.\Generated_Source\PSoC4/UART.c ****     *  None.
1221:.\Generated_Source\PSoC4/UART.c ****     *
1222:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1223:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1225:.\Generated_Source\PSoC4/UART.c ****     *
1226:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1227:.\Generated_Source\PSoC4/UART.c ****     *  No.
1228:.\Generated_Source\PSoC4/UART.c ****     *
1229:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC4/UART.c ****     void UART_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC4/UART.c ****     {
 584              		.loc 1 1231 0
 585              		.cfi_startproc
 586 0000 80B5     		push	{r7, lr}
 587              		.cfi_def_cfa_offset 8
 588              		.cfi_offset 7, -8
 589              		.cfi_offset 14, -4
 590 0002 82B0     		sub	sp, sp, #8
 591              		.cfi_def_cfa_offset 16
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 33


 592 0004 00AF     		add	r7, sp, #0
 593              		.cfi_def_cfa_register 7
 594 0006 021C     		mov	r2, r0
 595 0008 FB1D     		add	r3, r7, #7
 596 000a 1A70     		strb	r2, [r3]
1232:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 597              		.loc 1 1233 0
 598 000c 084B     		ldr	r3, .L46
 599 000e 1B78     		ldrb	r3, [r3]
 600 0010 002B     		cmp	r3, #0
 601 0012 0AD0     		beq	.L44
1234:.\Generated_Source\PSoC4/UART.c ****         {
1235:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(txDataByte);
 602              		.loc 1 1235 0
 603 0014 FB1D     		add	r3, r7, #7
 604 0016 1B78     		ldrb	r3, [r3]
 605 0018 181C     		mov	r0, r3
 606 001a FFF7FEFF 		bl	UART_PutChar
1236:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(0x0Du);
 607              		.loc 1 1236 0
 608 001e 0D20     		mov	r0, #13
 609 0020 FFF7FEFF 		bl	UART_PutChar
1237:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(0x0Au);
 610              		.loc 1 1237 0
 611 0024 0A20     		mov	r0, #10
 612 0026 FFF7FEFF 		bl	UART_PutChar
 613              	.L44:
1238:.\Generated_Source\PSoC4/UART.c ****         }
1239:.\Generated_Source\PSoC4/UART.c ****     }
 614              		.loc 1 1239 0
 615 002a BD46     		mov	sp, r7
 616 002c 02B0     		add	sp, sp, #8
 617              		@ sp needed
 618 002e 80BD     		pop	{r7, pc}
 619              	.L47:
 620              		.align	2
 621              	.L46:
 622 0030 00000000 		.word	UART_initVar
 623              		.cfi_endproc
 624              	.LFE12:
 625              		.size	UART_PutCRLF, .-UART_PutCRLF
 626              		.section	.text.UART_GetTxBufferSize,"ax",%progbits
 627              		.align	2
 628              		.global	UART_GetTxBufferSize
 629              		.code	16
 630              		.thumb_func
 631              		.type	UART_GetTxBufferSize, %function
 632              	UART_GetTxBufferSize:
 633              	.LFB13:
1240:.\Generated_Source\PSoC4/UART.c **** 
1241:.\Generated_Source\PSoC4/UART.c **** 
1242:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetTxBufferSize
1244:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC4/UART.c ****     *
1246:.\Generated_Source\PSoC4/UART.c ****     * Summary:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 34


1247:.\Generated_Source\PSoC4/UART.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC4/UART.c ****     *  transmitted.
1249:.\Generated_Source\PSoC4/UART.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC4/UART.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC4/UART.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC4/UART.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC4/UART.c ****     *    TX FIFO do not count.
1254:.\Generated_Source\PSoC4/UART.c ****     *
1255:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1256:.\Generated_Source\PSoC4/UART.c ****     *  None.
1257:.\Generated_Source\PSoC4/UART.c ****     *
1258:.\Generated_Source\PSoC4/UART.c ****     * Return:
1259:.\Generated_Source\PSoC4/UART.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC4/UART.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC4/UART.c ****     *
1262:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1263:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC4/UART.c ****     *
1266:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1267:.\Generated_Source\PSoC4/UART.c ****     *  No.
1268:.\Generated_Source\PSoC4/UART.c ****     *
1269:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1270:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC4/UART.c ****     *
1272:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC4/UART.c ****                                                             
1275:.\Generated_Source\PSoC4/UART.c ****     {
 634              		.loc 1 1275 0
 635              		.cfi_startproc
 636 0000 80B5     		push	{r7, lr}
 637              		.cfi_def_cfa_offset 8
 638              		.cfi_offset 7, -8
 639              		.cfi_offset 14, -4
 640 0002 82B0     		sub	sp, sp, #8
 641              		.cfi_def_cfa_offset 16
 642 0004 00AF     		add	r7, sp, #0
 643              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC4/UART.c ****         uint8 size;
1277:.\Generated_Source\PSoC4/UART.c **** 
1278:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC4/UART.c **** 
1280:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC4/UART.c ****         UART_DisableTxInt();
1282:.\Generated_Source\PSoC4/UART.c **** 
1283:.\Generated_Source\PSoC4/UART.c ****         if(UART_txBufferRead == UART_txBufferWrite)
1284:.\Generated_Source\PSoC4/UART.c ****         {
1285:.\Generated_Source\PSoC4/UART.c ****             size = 0u;
1286:.\Generated_Source\PSoC4/UART.c ****         }
1287:.\Generated_Source\PSoC4/UART.c ****         else if(UART_txBufferRead < UART_txBufferWrite)
1288:.\Generated_Source\PSoC4/UART.c ****         {
1289:.\Generated_Source\PSoC4/UART.c ****             size = (UART_txBufferWrite - UART_txBufferRead);
1290:.\Generated_Source\PSoC4/UART.c ****         }
1291:.\Generated_Source\PSoC4/UART.c ****         else
1292:.\Generated_Source\PSoC4/UART.c ****         {
1293:.\Generated_Source\PSoC4/UART.c ****             size = (UART_TX_BUFFER_SIZE - UART_txBufferRead) +
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 35


1294:.\Generated_Source\PSoC4/UART.c ****                     UART_txBufferWrite;
1295:.\Generated_Source\PSoC4/UART.c ****         }
1296:.\Generated_Source\PSoC4/UART.c **** 
1297:.\Generated_Source\PSoC4/UART.c ****         UART_EnableTxInt();
1298:.\Generated_Source\PSoC4/UART.c **** 
1299:.\Generated_Source\PSoC4/UART.c ****     #else
1300:.\Generated_Source\PSoC4/UART.c **** 
1301:.\Generated_Source\PSoC4/UART.c ****         size = UART_TXSTATUS_REG;
 644              		.loc 1 1301 0
 645 0006 0F4A     		ldr	r2, .L53
 646 0008 FB1D     		add	r3, r7, #7
 647 000a 1278     		ldrb	r2, [r2]
 648 000c 1A70     		strb	r2, [r3]
1302:.\Generated_Source\PSoC4/UART.c **** 
1303:.\Generated_Source\PSoC4/UART.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC4/UART.c ****         if((size & UART_TX_STS_FIFO_FULL) != 0u)
 649              		.loc 1 1304 0
 650 000e FB1D     		add	r3, r7, #7
 651 0010 1A78     		ldrb	r2, [r3]
 652 0012 0423     		mov	r3, #4
 653 0014 1340     		and	r3, r2
 654 0016 03D0     		beq	.L49
1305:.\Generated_Source\PSoC4/UART.c ****         {
1306:.\Generated_Source\PSoC4/UART.c ****             size = UART_FIFO_LENGTH;
 655              		.loc 1 1306 0
 656 0018 FB1D     		add	r3, r7, #7
 657 001a 0422     		mov	r2, #4
 658 001c 1A70     		strb	r2, [r3]
 659 001e 0BE0     		b	.L50
 660              	.L49:
1307:.\Generated_Source\PSoC4/UART.c ****         }
1308:.\Generated_Source\PSoC4/UART.c ****         else if((size & UART_TX_STS_FIFO_EMPTY) != 0u)
 661              		.loc 1 1308 0
 662 0020 FB1D     		add	r3, r7, #7
 663 0022 1A78     		ldrb	r2, [r3]
 664 0024 0223     		mov	r3, #2
 665 0026 1340     		and	r3, r2
 666 0028 03D0     		beq	.L51
1309:.\Generated_Source\PSoC4/UART.c ****         {
1310:.\Generated_Source\PSoC4/UART.c ****             size = 0u;
 667              		.loc 1 1310 0
 668 002a FB1D     		add	r3, r7, #7
 669 002c 0022     		mov	r2, #0
 670 002e 1A70     		strb	r2, [r3]
 671 0030 02E0     		b	.L50
 672              	.L51:
1311:.\Generated_Source\PSoC4/UART.c ****         }
1312:.\Generated_Source\PSoC4/UART.c ****         else
1313:.\Generated_Source\PSoC4/UART.c ****         {
1314:.\Generated_Source\PSoC4/UART.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC4/UART.c ****             size = 1u;
 673              		.loc 1 1315 0
 674 0032 FB1D     		add	r3, r7, #7
 675 0034 0122     		mov	r2, #1
 676 0036 1A70     		strb	r2, [r3]
 677              	.L50:
1316:.\Generated_Source\PSoC4/UART.c ****         }
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 36


1317:.\Generated_Source\PSoC4/UART.c **** 
1318:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC4/UART.c **** 
1320:.\Generated_Source\PSoC4/UART.c ****     return(size);
 678              		.loc 1 1320 0
 679 0038 FB1D     		add	r3, r7, #7
 680 003a 1B78     		ldrb	r3, [r3]
1321:.\Generated_Source\PSoC4/UART.c ****     }
 681              		.loc 1 1321 0
 682 003c 181C     		mov	r0, r3
 683 003e BD46     		mov	sp, r7
 684 0040 02B0     		add	sp, sp, #8
 685              		@ sp needed
 686 0042 80BD     		pop	{r7, pc}
 687              	.L54:
 688              		.align	2
 689              	.L53:
 690 0044 63000F40 		.word	1074724963
 691              		.cfi_endproc
 692              	.LFE13:
 693              		.size	UART_GetTxBufferSize, .-UART_GetTxBufferSize
 694              		.section	.text.UART_ClearTxBuffer,"ax",%progbits
 695              		.align	2
 696              		.global	UART_ClearTxBuffer
 697              		.code	16
 698              		.thumb_func
 699              		.type	UART_ClearTxBuffer, %function
 700              	UART_ClearTxBuffer:
 701              	.LFB14:
1322:.\Generated_Source\PSoC4/UART.c **** 
1323:.\Generated_Source\PSoC4/UART.c **** 
1324:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ClearTxBuffer
1326:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC4/UART.c ****     *
1328:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1329:.\Generated_Source\PSoC4/UART.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC4/UART.c ****     *
1331:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1332:.\Generated_Source\PSoC4/UART.c ****     *  None.
1333:.\Generated_Source\PSoC4/UART.c ****     *
1334:.\Generated_Source\PSoC4/UART.c ****     * Return:
1335:.\Generated_Source\PSoC4/UART.c ****     *  None.
1336:.\Generated_Source\PSoC4/UART.c ****     *
1337:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1338:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC4/UART.c ****     *
1341:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1342:.\Generated_Source\PSoC4/UART.c ****     *  No.
1343:.\Generated_Source\PSoC4/UART.c ****     *
1344:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1345:.\Generated_Source\PSoC4/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC4/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC4/UART.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC4/UART.c ****     *
1349:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 37


1350:.\Generated_Source\PSoC4/UART.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC4/UART.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC4/UART.c ****     *
1353:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC4/UART.c ****     void UART_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC4/UART.c ****     {
 702              		.loc 1 1355 0
 703              		.cfi_startproc
 704 0000 90B5     		push	{r4, r7, lr}
 705              		.cfi_def_cfa_offset 12
 706              		.cfi_offset 4, -12
 707              		.cfi_offset 7, -8
 708              		.cfi_offset 14, -4
 709 0002 83B0     		sub	sp, sp, #12
 710              		.cfi_def_cfa_offset 24
 711 0004 00AF     		add	r7, sp, #0
 712              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC4/UART.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC4/UART.c **** 
1358:.\Generated_Source\PSoC4/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 713              		.loc 1 1358 0
 714 0006 FC1D     		add	r4, r7, #7
 715 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 716 000c 031C     		mov	r3, r0
 717 000e 2370     		strb	r3, [r4]
1359:.\Generated_Source\PSoC4/UART.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_AUX_CTL_REG |= (uint8)  UART_TX_FIFO_CLR;
 718              		.loc 1 1360 0
 719 0010 0B4B     		ldr	r3, .L56
 720 0012 0B4A     		ldr	r2, .L56
 721 0014 1278     		ldrb	r2, [r2]
 722 0016 D2B2     		uxtb	r2, r2
 723 0018 0121     		mov	r1, #1
 724 001a 0A43     		orr	r2, r1
 725 001c D2B2     		uxtb	r2, r2
 726 001e 1A70     		strb	r2, [r3]
1361:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_AUX_CTL_REG &= (uint8) ~UART_TX_FIFO_CLR;
 727              		.loc 1 1361 0
 728 0020 074B     		ldr	r3, .L56
 729 0022 074A     		ldr	r2, .L56
 730 0024 1278     		ldrb	r2, [r2]
 731 0026 D2B2     		uxtb	r2, r2
 732 0028 0121     		mov	r1, #1
 733 002a 8A43     		bic	r2, r1
 734 002c D2B2     		uxtb	r2, r2
 735 002e 1A70     		strb	r2, [r3]
1362:.\Generated_Source\PSoC4/UART.c ****         CyExitCriticalSection(enableInterrupts);
 736              		.loc 1 1362 0
 737 0030 FB1D     		add	r3, r7, #7
 738 0032 1B78     		ldrb	r3, [r3]
 739 0034 181C     		mov	r0, r3
 740 0036 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC4/UART.c **** 
1364:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC4/UART.c **** 
1366:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC4/UART.c ****         UART_DisableTxInt();
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 38


1368:.\Generated_Source\PSoC4/UART.c **** 
1369:.\Generated_Source\PSoC4/UART.c ****         UART_txBufferRead = 0u;
1370:.\Generated_Source\PSoC4/UART.c ****         UART_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC4/UART.c **** 
1372:.\Generated_Source\PSoC4/UART.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC4/UART.c ****         UART_EnableTxInt();
1374:.\Generated_Source\PSoC4/UART.c **** 
1375:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC4/UART.c ****     }
 741              		.loc 1 1376 0
 742 003a BD46     		mov	sp, r7
 743 003c 03B0     		add	sp, sp, #12
 744              		@ sp needed
 745 003e 90BD     		pop	{r4, r7, pc}
 746              	.L57:
 747              		.align	2
 748              	.L56:
 749 0040 93000F40 		.word	1074725011
 750              		.cfi_endproc
 751              	.LFE14:
 752              		.size	UART_ClearTxBuffer, .-UART_ClearTxBuffer
 753              		.section	.text.UART_SendBreak,"ax",%progbits
 754              		.align	2
 755              		.global	UART_SendBreak
 756              		.code	16
 757              		.thumb_func
 758              		.type	UART_SendBreak, %function
 759              	UART_SendBreak:
 760              	.LFB15:
1377:.\Generated_Source\PSoC4/UART.c **** 
1378:.\Generated_Source\PSoC4/UART.c **** 
1379:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SendBreak
1381:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC4/UART.c ****     *
1383:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1384:.\Generated_Source\PSoC4/UART.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC4/UART.c ****     *
1386:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1387:.\Generated_Source\PSoC4/UART.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC4/UART.c ****     *   UART_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC4/UART.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC4/UART.c ****     *   UART_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC4/UART.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC4/UART.c ****     *   UART_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC4/UART.c ****     *       then return.
1394:.\Generated_Source\PSoC4/UART.c ****     *   UART_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC4/UART.c ****     *      UART_SEND_BREAK and UART_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC4/UART.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC4/UART.c ****     *
1398:.\Generated_Source\PSoC4/UART.c ****     * Return:
1399:.\Generated_Source\PSoC4/UART.c ****     *  None.
1400:.\Generated_Source\PSoC4/UART.c ****     *
1401:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1402:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1404:.\Generated_Source\PSoC4/UART.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 39


1405:.\Generated_Source\PSoC4/UART.c ****     *
1406:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1407:.\Generated_Source\PSoC4/UART.c ****     *  No.
1408:.\Generated_Source\PSoC4/UART.c ****     *
1409:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1410:.\Generated_Source\PSoC4/UART.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC4/UART.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC4/UART.c ****     *  operation.
1413:.\Generated_Source\PSoC4/UART.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC4/UART.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC4/UART.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC4/UART.c ****     *     complete.
1417:.\Generated_Source\PSoC4/UART.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC4/UART.c ****     *     operation
1419:.\Generated_Source\PSoC4/UART.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC4/UART.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC4/UART.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC4/UART.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC4/UART.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC4/UART.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC4/UART.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC4/UART.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC4/UART.c ****     *
1432:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
1433:.\Generated_Source\PSoC4/UART.c ****     *  The UART_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC4/UART.c ****     *  break signal.
1435:.\Generated_Source\PSoC4/UART.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC4/UART.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC4/UART.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC4/UART.c ****     *
1439:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC4/UART.c ****     void UART_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC4/UART.c ****     {
 761              		.loc 1 1441 0
 762              		.cfi_startproc
 763 0000 80B5     		push	{r7, lr}
 764              		.cfi_def_cfa_offset 8
 765              		.cfi_offset 7, -8
 766              		.cfi_offset 14, -4
 767 0002 84B0     		sub	sp, sp, #16
 768              		.cfi_def_cfa_offset 24
 769 0004 00AF     		add	r7, sp, #0
 770              		.cfi_def_cfa_register 7
 771 0006 021C     		mov	r2, r0
 772 0008 FB1D     		add	r3, r7, #7
 773 000a 1A70     		strb	r2, [r3]
1442:.\Generated_Source\PSoC4/UART.c **** 
1443:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 774              		.loc 1 1444 0
 775 000c 254B     		ldr	r3, .L66
 776 000e 1B78     		ldrb	r3, [r3]
 777 0010 002B     		cmp	r3, #0
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 40


 778 0012 43D0     		beq	.L58
 779              	.LBB2:
1445:.\Generated_Source\PSoC4/UART.c ****         {
1446:.\Generated_Source\PSoC4/UART.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC4/UART.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC4/UART.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC4/UART.c **** 
1450:.\Generated_Source\PSoC4/UART.c ****         #if(UART_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC4/UART.c **** 
1452:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
1453:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC4/UART.c ****             {
1455:.\Generated_Source\PSoC4/UART.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() |
1457:.\Generated_Source\PSoC4/UART.c ****                                                       UART_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC4/UART.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC4/UART.c **** 
1461:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC4/UART.c ****                 {
1463:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1464:.\Generated_Source\PSoC4/UART.c ****                 }
1465:.\Generated_Source\PSoC4/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC4/UART.c ****             }
1467:.\Generated_Source\PSoC4/UART.c **** 
1468:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC4/UART.c ****             {
1471:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC4/UART.c ****                 {
1473:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1474:.\Generated_Source\PSoC4/UART.c ****                 }
1475:.\Generated_Source\PSoC4/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC4/UART.c ****             }
1477:.\Generated_Source\PSoC4/UART.c **** 
1478:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_REINIT) ||
1480:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC4/UART.c ****             {
1482:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1483:.\Generated_Source\PSoC4/UART.c ****                                               (uint8)~UART_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC4/UART.c ****             }
1485:.\Generated_Source\PSoC4/UART.c **** 
1486:.\Generated_Source\PSoC4/UART.c ****         #else /* UART_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC4/UART.c **** 
1488:.\Generated_Source\PSoC4/UART.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC4/UART.c **** 
1490:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
 780              		.loc 1 1490 0
 781 0014 FB1D     		add	r3, r7, #7
 782 0016 1B78     		ldrb	r3, [r3]
 783 0018 002B     		cmp	r3, #0
 784 001a 03D0     		beq	.L60
 785              		.loc 1 1490 0 is_stmt 0 discriminator 1
 786 001c FB1D     		add	r3, r7, #7
 787 001e 1B78     		ldrb	r3, [r3]
 788 0020 032B     		cmp	r3, #3
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 41


 789 0022 15D1     		bne	.L61
 790              	.L60:
1491:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC4/UART.c ****             {
1493:.\Generated_Source\PSoC4/UART.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC4/UART.c ****                 #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC4/UART.c ****                                     (UART_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC4/UART.c ****                     UART_WriteControlRegister(UART_ReadControlRegister() |
1497:.\Generated_Source\PSoC4/UART.c ****                                                           UART_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_PARITY_TYPE != UART__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC4/UART.c **** 
1500:.\Generated_Source\PSoC4/UART.c ****                 #if(UART_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC4/UART.c ****                     txPeriod = UART_TXBITCLKTX_COMPLETE_REG;
 791              		.loc 1 1501 0 is_stmt 1
 792 0024 204B     		ldr	r3, .L66+4
 793 0026 1B78     		ldrb	r3, [r3]
 794 0028 DAB2     		uxtb	r2, r3
 795 002a 204B     		ldr	r3, .L66+8
 796 002c 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC4/UART.c ****                     UART_TXBITCLKTX_COMPLETE_REG = UART_TXBITCTR_BREAKBITS;
 797              		.loc 1 1502 0
 798 002e 1E4B     		ldr	r3, .L66+4
 799 0030 6722     		mov	r2, #103
 800 0032 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC4/UART.c ****                 #else
1504:.\Generated_Source\PSoC4/UART.c ****                     txPeriod = UART_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC4/UART.c ****                     UART_TXBITCTR_PERIOD_REG = UART_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC4/UART.c **** 
1508:.\Generated_Source\PSoC4/UART.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = 0u;
 801              		.loc 1 1509 0
 802 0034 1E4B     		ldr	r3, .L66+12
 803 0036 0022     		mov	r2, #0
 804 0038 1A70     		strb	r2, [r3]
 805              	.L62:
1510:.\Generated_Source\PSoC4/UART.c **** 
1511:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC4/UART.c ****                 {
1513:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 806              		.loc 1 1513 0 discriminator 1
 807 003a 1E4A     		ldr	r2, .L66+16
 808 003c 3B1C     		mov	r3, r7
 809 003e 0F33     		add	r3, r3, #15
 810 0040 1278     		ldrb	r2, [r2]
 811 0042 1A70     		strb	r2, [r3]
1514:.\Generated_Source\PSoC4/UART.c ****                 }
1515:.\Generated_Source\PSoC4/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
 812              		.loc 1 1515 0 discriminator 1
 813 0044 3B1C     		mov	r3, r7
 814 0046 0F33     		add	r3, r3, #15
 815 0048 1A78     		ldrb	r2, [r3]
 816 004a 0223     		mov	r3, #2
 817 004c 1340     		and	r3, r2
 818 004e F4D1     		bne	.L62
 819              	.L61:
1516:.\Generated_Source\PSoC4/UART.c ****             }
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 42


1517:.\Generated_Source\PSoC4/UART.c **** 
1518:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 820              		.loc 1 1518 0
 821 0050 FB1D     		add	r3, r7, #7
 822 0052 1B78     		ldrb	r3, [r3]
 823 0054 012B     		cmp	r3, #1
 824 0056 03D0     		beq	.L63
 825              		.loc 1 1518 0 is_stmt 0 discriminator 1
 826 0058 FB1D     		add	r3, r7, #7
 827 005a 1B78     		ldrb	r3, [r3]
 828 005c 032B     		cmp	r3, #3
 829 005e 0DD1     		bne	.L64
 830              	.L63:
1519:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC4/UART.c ****             {
1521:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC4/UART.c ****                 {
1523:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 831              		.loc 1 1523 0 is_stmt 1 discriminator 1
 832 0060 144A     		ldr	r2, .L66+16
 833 0062 3B1C     		mov	r3, r7
 834 0064 0F33     		add	r3, r3, #15
 835 0066 1278     		ldrb	r2, [r2]
 836 0068 1A70     		strb	r2, [r3]
1524:.\Generated_Source\PSoC4/UART.c ****                 }
1525:.\Generated_Source\PSoC4/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
 837              		.loc 1 1525 0 discriminator 1
 838 006a 3B1C     		mov	r3, r7
 839 006c 0F33     		add	r3, r3, #15
 840 006e 1B78     		ldrb	r3, [r3]
 841 0070 DB43     		mvn	r3, r3
 842 0072 DBB2     		uxtb	r3, r3
 843 0074 1A1C     		mov	r2, r3
 844 0076 0123     		mov	r3, #1
 845 0078 1340     		and	r3, r2
 846 007a F1D1     		bne	.L63
 847              	.L64:
1526:.\Generated_Source\PSoC4/UART.c ****             }
1527:.\Generated_Source\PSoC4/UART.c **** 
1528:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 848              		.loc 1 1528 0
 849 007c FB1D     		add	r3, r7, #7
 850 007e 1B78     		ldrb	r3, [r3]
 851 0080 012B     		cmp	r3, #1
 852 0082 07D0     		beq	.L65
 853              		.loc 1 1528 0 is_stmt 0 discriminator 1
 854 0084 FB1D     		add	r3, r7, #7
 855 0086 1B78     		ldrb	r3, [r3]
 856 0088 022B     		cmp	r3, #2
 857 008a 03D0     		beq	.L65
1529:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_REINIT) ||
 858              		.loc 1 1529 0 is_stmt 1
 859 008c FB1D     		add	r3, r7, #7
 860 008e 1B78     		ldrb	r3, [r3]
 861 0090 032B     		cmp	r3, #3
 862 0092 03D1     		bne	.L58
 863              	.L65:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 43


1530:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC4/UART.c ****             {
1532:.\Generated_Source\PSoC4/UART.c **** 
1533:.\Generated_Source\PSoC4/UART.c ****             #if(UART_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC4/UART.c ****                 UART_TXBITCLKTX_COMPLETE_REG = txPeriod;
 864              		.loc 1 1534 0
 865 0094 044B     		ldr	r3, .L66+4
 866 0096 054A     		ldr	r2, .L66+8
 867 0098 1278     		ldrb	r2, [r2]
 868 009a 1A70     		strb	r2, [r3]
 869              	.L58:
 870              	.LBE2:
1535:.\Generated_Source\PSoC4/UART.c ****             #else
1536:.\Generated_Source\PSoC4/UART.c ****                 UART_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC4/UART.c **** 
1539:.\Generated_Source\PSoC4/UART.c ****             #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC4/UART.c ****                  (UART_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1542:.\Generated_Source\PSoC4/UART.c ****                                                       (uint8) ~UART_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC4/UART.c ****             }
1545:.\Generated_Source\PSoC4/UART.c ****         #endif    /* End UART_HD_ENABLED */
1546:.\Generated_Source\PSoC4/UART.c ****         }
1547:.\Generated_Source\PSoC4/UART.c ****     }
 871              		.loc 1 1547 0
 872 009c BD46     		mov	sp, r7
 873 009e 04B0     		add	sp, sp, #16
 874              		@ sp needed
 875 00a0 80BD     		pop	{r7, pc}
 876              	.L67:
 877 00a2 C046     		.align	2
 878              	.L66:
 879 00a4 00000000 		.word	UART_initVar
 880 00a8 32000F40 		.word	1074724914
 881 00ac 01000000 		.word	txPeriod.4771
 882 00b0 43000F40 		.word	1074724931
 883 00b4 63000F40 		.word	1074724963
 884              		.cfi_endproc
 885              	.LFE15:
 886              		.size	UART_SendBreak, .-UART_SendBreak
 887              		.section	.text.UART_SetTxAddressMode,"ax",%progbits
 888              		.align	2
 889              		.global	UART_SetTxAddressMode
 890              		.code	16
 891              		.thumb_func
 892              		.type	UART_SetTxAddressMode, %function
 893              	UART_SetTxAddressMode:
 894              	.LFB16:
1548:.\Generated_Source\PSoC4/UART.c **** 
1549:.\Generated_Source\PSoC4/UART.c **** 
1550:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetTxAddressMode
1552:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC4/UART.c ****     *
1554:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1555:.\Generated_Source\PSoC4/UART.c ****     *  Configures the transmitter to signal the next bytes is address or data.
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 44


1556:.\Generated_Source\PSoC4/UART.c ****     *
1557:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1558:.\Generated_Source\PSoC4/UART.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC4/UART.c ****     *       UART_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC4/UART.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC4/UART.c ****     *       UART_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC4/UART.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC4/UART.c ****     *
1564:.\Generated_Source\PSoC4/UART.c ****     * Return:
1565:.\Generated_Source\PSoC4/UART.c ****     *  None.
1566:.\Generated_Source\PSoC4/UART.c ****     *
1567:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
1568:.\Generated_Source\PSoC4/UART.c ****     *  This function sets and clears UART_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC4/UART.c ****     *  register.
1570:.\Generated_Source\PSoC4/UART.c ****     *
1571:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC4/UART.c ****     void UART_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC4/UART.c ****     {
 895              		.loc 1 1573 0
 896              		.cfi_startproc
 897 0000 80B5     		push	{r7, lr}
 898              		.cfi_def_cfa_offset 8
 899              		.cfi_offset 7, -8
 900              		.cfi_offset 14, -4
 901 0002 82B0     		sub	sp, sp, #8
 902              		.cfi_def_cfa_offset 16
 903 0004 00AF     		add	r7, sp, #0
 904              		.cfi_def_cfa_register 7
 905 0006 021C     		mov	r2, r0
 906 0008 FB1D     		add	r3, r7, #7
 907 000a 1A70     		strb	r2, [r3]
1574:.\Generated_Source\PSoC4/UART.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC4/UART.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC4/UART.c ****         {
1577:.\Generated_Source\PSoC4/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC4/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() |
1579:.\Generated_Source\PSoC4/UART.c ****                                                   UART_CTRL_MARK);
1580:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC4/UART.c ****         }
1582:.\Generated_Source\PSoC4/UART.c ****         else
1583:.\Generated_Source\PSoC4/UART.c ****         {
1584:.\Generated_Source\PSoC4/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC4/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() &
1586:.\Generated_Source\PSoC4/UART.c ****                                                   (uint8) ~UART_CTRL_MARK);
1587:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC4/UART.c ****         }
1589:.\Generated_Source\PSoC4/UART.c ****     }
 908              		.loc 1 1589 0
 909 000c BD46     		mov	sp, r7
 910 000e 02B0     		add	sp, sp, #8
 911              		@ sp needed
 912 0010 80BD     		pop	{r7, pc}
 913              		.cfi_endproc
 914              	.LFE16:
 915              		.size	UART_SetTxAddressMode, .-UART_SetTxAddressMode
 916 0012 C046     		.bss
 917              	txPeriod.4771:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 45


 918 0001 00       		.space	1
 919              		.text
 920              	.Letext0:
 921              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 922              		.section	.debug_info,"",%progbits
 923              	.Ldebug_info0:
 924 0000 71030000 		.4byte	0x371
 925 0004 0400     		.2byte	0x4
 926 0006 00000000 		.4byte	.Ldebug_abbrev0
 927 000a 04       		.byte	0x4
 928 000b 01       		.uleb128 0x1
 929 000c 79000000 		.4byte	.LASF45
 930 0010 01       		.byte	0x1
 931 0011 C2010000 		.4byte	.LASF46
 932 0015 76010000 		.4byte	.LASF47
 933 0019 00000000 		.4byte	.Ldebug_ranges0+0
 934 001d 00000000 		.4byte	0
 935 0021 00000000 		.4byte	.Ldebug_line0
 936 0025 02       		.uleb128 0x2
 937 0026 01       		.byte	0x1
 938 0027 06       		.byte	0x6
 939 0028 F4020000 		.4byte	.LASF0
 940 002c 02       		.uleb128 0x2
 941 002d 01       		.byte	0x1
 942 002e 08       		.byte	0x8
 943 002f 68010000 		.4byte	.LASF1
 944 0033 02       		.uleb128 0x2
 945 0034 02       		.byte	0x2
 946 0035 05       		.byte	0x5
 947 0036 BC020000 		.4byte	.LASF2
 948 003a 02       		.uleb128 0x2
 949 003b 02       		.byte	0x2
 950 003c 07       		.byte	0x7
 951 003d 4C000000 		.4byte	.LASF3
 952 0041 02       		.uleb128 0x2
 953 0042 04       		.byte	0x4
 954 0043 05       		.byte	0x5
 955 0044 EB020000 		.4byte	.LASF4
 956 0048 02       		.uleb128 0x2
 957 0049 04       		.byte	0x4
 958 004a 07       		.byte	0x7
 959 004b 1C010000 		.4byte	.LASF5
 960 004f 02       		.uleb128 0x2
 961 0050 08       		.byte	0x8
 962 0051 05       		.byte	0x5
 963 0052 00000000 		.4byte	.LASF6
 964 0056 02       		.uleb128 0x2
 965 0057 08       		.byte	0x8
 966 0058 07       		.byte	0x7
 967 0059 1B020000 		.4byte	.LASF7
 968 005d 03       		.uleb128 0x3
 969 005e 04       		.byte	0x4
 970 005f 05       		.byte	0x5
 971 0060 696E7400 		.ascii	"int\000"
 972 0064 02       		.uleb128 0x2
 973 0065 04       		.byte	0x4
 974 0066 07       		.byte	0x7
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 46


 975 0067 E2010000 		.4byte	.LASF8
 976 006b 04       		.uleb128 0x4
 977 006c 2E010000 		.4byte	.LASF9
 978 0070 02       		.byte	0x2
 979 0071 A1       		.byte	0xa1
 980 0072 2C000000 		.4byte	0x2c
 981 0076 04       		.uleb128 0x4
 982 0077 AC010000 		.4byte	.LASF10
 983 007b 02       		.byte	0x2
 984 007c A2       		.byte	0xa2
 985 007d 3A000000 		.4byte	0x3a
 986 0081 02       		.uleb128 0x2
 987 0082 04       		.byte	0x4
 988 0083 04       		.byte	0x4
 989 0084 73000000 		.4byte	.LASF11
 990 0088 02       		.uleb128 0x2
 991 0089 08       		.byte	0x8
 992 008a 04       		.byte	0x4
 993 008b 9E010000 		.4byte	.LASF12
 994 008f 04       		.uleb128 0x4
 995 0090 17000000 		.4byte	.LASF13
 996 0094 02       		.byte	0x2
 997 0095 B2       		.byte	0xb2
 998 0096 9A000000 		.4byte	0x9a
 999 009a 02       		.uleb128 0x2
 1000 009b 01       		.byte	0x1
 1001 009c 08       		.byte	0x8
 1002 009d AF020000 		.4byte	.LASF14
 1003 00a1 05       		.uleb128 0x5
 1004 00a2 17010000 		.4byte	.LASF15
 1005 00a6 02       		.byte	0x2
 1006 00a7 4B01     		.2byte	0x14b
 1007 00a9 AD000000 		.4byte	0xad
 1008 00ad 06       		.uleb128 0x6
 1009 00ae 6B000000 		.4byte	0x6b
 1010 00b2 02       		.uleb128 0x2
 1011 00b3 04       		.byte	0x4
 1012 00b4 07       		.byte	0x7
 1013 00b5 9B020000 		.4byte	.LASF16
 1014 00b9 07       		.uleb128 0x7
 1015 00ba 34010000 		.4byte	.LASF17
 1016 00be 01       		.byte	0x1
 1017 00bf 4C       		.byte	0x4c
 1018 00c0 00000000 		.4byte	.LFB0
 1019 00c4 24000000 		.4byte	.LFE0-.LFB0
 1020 00c8 01       		.uleb128 0x1
 1021 00c9 9C       		.byte	0x9c
 1022 00ca 08       		.uleb128 0x8
 1023 00cb 0D010000 		.4byte	.LASF18
 1024 00cf 01       		.byte	0x1
 1025 00d0 6A       		.byte	0x6a
 1026 00d1 00000000 		.4byte	.LFB1
 1027 00d5 28000000 		.4byte	.LFE1-.LFB1
 1028 00d9 01       		.uleb128 0x1
 1029 00da 9C       		.byte	0x9c
 1030 00db 09       		.uleb128 0x9
 1031 00dc F5000000 		.4byte	.LASF19
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 47


 1032 00e0 01       		.byte	0x1
 1033 00e1 B7       		.byte	0xb7
 1034 00e2 00000000 		.4byte	.LFB2
 1035 00e6 38000000 		.4byte	.LFE2-.LFB2
 1036 00ea 01       		.uleb128 0x1
 1037 00eb 9C       		.byte	0x9c
 1038 00ec FF000000 		.4byte	0xff
 1039 00f0 0A       		.uleb128 0xa
 1040 00f1 57010000 		.4byte	.LASF21
 1041 00f5 01       		.byte	0x1
 1042 00f6 B9       		.byte	0xb9
 1043 00f7 6B000000 		.4byte	0x6b
 1044 00fb 02       		.uleb128 0x2
 1045 00fc 91       		.byte	0x91
 1046 00fd 6F       		.sleb128 -17
 1047 00fe 00       		.byte	0
 1048 00ff 09       		.uleb128 0x9
 1049 0100 D9020000 		.4byte	.LASF20
 1050 0104 01       		.byte	0x1
 1051 0105 F0       		.byte	0xf0
 1052 0106 00000000 		.4byte	.LFB3
 1053 010a 38000000 		.4byte	.LFE3-.LFB3
 1054 010e 01       		.uleb128 0x1
 1055 010f 9C       		.byte	0x9c
 1056 0110 23010000 		.4byte	0x123
 1057 0114 0A       		.uleb128 0xa
 1058 0115 57010000 		.4byte	.LASF21
 1059 0119 01       		.byte	0x1
 1060 011a F2       		.byte	0xf2
 1061 011b 6B000000 		.4byte	0x6b
 1062 011f 02       		.uleb128 0x2
 1063 0120 91       		.byte	0x91
 1064 0121 6F       		.sleb128 -17
 1065 0122 00       		.byte	0
 1066 0123 0B       		.uleb128 0xb
 1067 0124 32020000 		.4byte	.LASF28
 1068 0128 01       		.byte	0x1
 1069 0129 2701     		.2byte	0x127
 1070 012b 6B000000 		.4byte	0x6b
 1071 012f 00000000 		.4byte	.LFB4
 1072 0133 0C000000 		.4byte	.LFE4-.LFB4
 1073 0137 01       		.uleb128 0x1
 1074 0138 9C       		.byte	0x9c
 1075 0139 0C       		.uleb128 0xc
 1076 013a EF010000 		.4byte	.LASF22
 1077 013e 01       		.byte	0x1
 1078 013f 3F01     		.2byte	0x13f
 1079 0141 00000000 		.4byte	.LFB5
 1080 0145 12000000 		.4byte	.LFE5-.LFB5
 1081 0149 01       		.uleb128 0x1
 1082 014a 9C       		.byte	0x9c
 1083 014b 5F010000 		.4byte	0x15f
 1084 014f 0D       		.uleb128 0xd
 1085 0150 E3020000 		.4byte	.LASF24
 1086 0154 01       		.byte	0x1
 1087 0155 3F01     		.2byte	0x13f
 1088 0157 6B000000 		.4byte	0x6b
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 48


 1089 015b 02       		.uleb128 0x2
 1090 015c 91       		.byte	0x91
 1091 015d 77       		.sleb128 -9
 1092 015e 00       		.byte	0
 1093 015f 0C       		.uleb128 0xc
 1094 0160 61020000 		.4byte	.LASF23
 1095 0164 01       		.byte	0x1
 1096 0165 8C03     		.2byte	0x38c
 1097 0167 00000000 		.4byte	.LFB6
 1098 016b 20000000 		.4byte	.LFE6-.LFB6
 1099 016f 01       		.uleb128 0x1
 1100 0170 9C       		.byte	0x9c
 1101 0171 85010000 		.4byte	0x185
 1102 0175 0D       		.uleb128 0xd
 1103 0176 A5010000 		.4byte	.LASF25
 1104 017a 01       		.byte	0x1
 1105 017b 8C03     		.2byte	0x38c
 1106 017d 6B000000 		.4byte	0x6b
 1107 0181 02       		.uleb128 0x2
 1108 0182 91       		.byte	0x91
 1109 0183 77       		.sleb128 -9
 1110 0184 00       		.byte	0
 1111 0185 0C       		.uleb128 0xc
 1112 0186 1D000000 		.4byte	.LASF26
 1113 018a 01       		.byte	0x1
 1114 018b AE03     		.2byte	0x3ae
 1115 018d 00000000 		.4byte	.LFB7
 1116 0191 2C000000 		.4byte	.LFE7-.LFB7
 1117 0195 01       		.uleb128 0x1
 1118 0196 9C       		.byte	0x9c
 1119 0197 AB010000 		.4byte	0x1ab
 1120 019b 0D       		.uleb128 0xd
 1121 019c A4020000 		.4byte	.LASF27
 1122 01a0 01       		.byte	0x1
 1123 01a1 AE03     		.2byte	0x3ae
 1124 01a3 6B000000 		.4byte	0x6b
 1125 01a7 02       		.uleb128 0x2
 1126 01a8 91       		.byte	0x91
 1127 01a9 77       		.sleb128 -9
 1128 01aa 00       		.byte	0
 1129 01ab 0B       		.uleb128 0xb
 1130 01ac 09020000 		.4byte	.LASF29
 1131 01b0 01       		.byte	0x1
 1132 01b1 EB03     		.2byte	0x3eb
 1133 01b3 6B000000 		.4byte	0x6b
 1134 01b7 00000000 		.4byte	.LFB8
 1135 01bb 14000000 		.4byte	.LFE8-.LFB8
 1136 01bf 01       		.uleb128 0x1
 1137 01c0 9C       		.byte	0x9c
 1138 01c1 0C       		.uleb128 0xc
 1139 01c2 79020000 		.4byte	.LASF30
 1140 01c6 01       		.byte	0x1
 1141 01c7 1104     		.2byte	0x411
 1142 01c9 00000000 		.4byte	.LFB9
 1143 01cd 34000000 		.4byte	.LFE9-.LFB9
 1144 01d1 01       		.uleb128 0x1
 1145 01d2 9C       		.byte	0x9c
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 49


 1146 01d3 E7010000 		.4byte	0x1e7
 1147 01d7 0D       		.uleb128 0xd
 1148 01d8 A4020000 		.4byte	.LASF27
 1149 01dc 01       		.byte	0x1
 1150 01dd 1104     		.2byte	0x411
 1151 01df 6B000000 		.4byte	0x6b
 1152 01e3 02       		.uleb128 0x2
 1153 01e4 91       		.byte	0x91
 1154 01e5 77       		.sleb128 -9
 1155 01e6 00       		.byte	0
 1156 01e7 0E       		.uleb128 0xe
 1157 01e8 00030000 		.4byte	.LASF31
 1158 01ec 01       		.byte	0x1
 1159 01ed 7904     		.2byte	0x479
 1160 01ef 00000000 		.4byte	.LFB10
 1161 01f3 54000000 		.4byte	.LFE10-.LFB10
 1162 01f7 01       		.uleb128 0x1
 1163 01f8 9C       		.byte	0x9c
 1164 01f9 1C020000 		.4byte	0x21c
 1165 01fd 0D       		.uleb128 0xd
 1166 01fe 6C000000 		.4byte	.LASF32
 1167 0202 01       		.byte	0x1
 1168 0203 7904     		.2byte	0x479
 1169 0205 1C020000 		.4byte	0x21c
 1170 0209 02       		.uleb128 0x2
 1171 020a 91       		.byte	0x91
 1172 020b 6C       		.sleb128 -20
 1173 020c 0F       		.uleb128 0xf
 1174 020d 58020000 		.4byte	.LASF33
 1175 0211 01       		.byte	0x1
 1176 0212 7B04     		.2byte	0x47b
 1177 0214 76000000 		.4byte	0x76
 1178 0218 02       		.uleb128 0x2
 1179 0219 91       		.byte	0x91
 1180 021a 76       		.sleb128 -10
 1181 021b 00       		.byte	0
 1182 021c 10       		.uleb128 0x10
 1183 021d 04       		.byte	0x4
 1184 021e 22020000 		.4byte	0x222
 1185 0222 11       		.uleb128 0x11
 1186 0223 8F000000 		.4byte	0x8f
 1187 0227 0E       		.uleb128 0xe
 1188 0228 3F010000 		.4byte	.LASF34
 1189 022c 01       		.byte	0x1
 1190 022d A704     		.2byte	0x4a7
 1191 022f 00000000 		.4byte	.LFB11
 1192 0233 58000000 		.4byte	.LFE11-.LFB11
 1193 0237 01       		.uleb128 0x1
 1194 0238 9C       		.byte	0x9c
 1195 0239 6B020000 		.4byte	0x26b
 1196 023d 0D       		.uleb128 0xd
 1197 023e 6C000000 		.4byte	.LASF32
 1198 0242 01       		.byte	0x1
 1199 0243 A704     		.2byte	0x4a7
 1200 0245 6B020000 		.4byte	0x26b
 1201 0249 02       		.uleb128 0x2
 1202 024a 91       		.byte	0x91
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 50


 1203 024b 6C       		.sleb128 -20
 1204 024c 0D       		.uleb128 0xd
 1205 024d 4D010000 		.4byte	.LASF35
 1206 0251 01       		.byte	0x1
 1207 0252 A704     		.2byte	0x4a7
 1208 0254 6B000000 		.4byte	0x6b
 1209 0258 02       		.uleb128 0x2
 1210 0259 91       		.byte	0x91
 1211 025a 6B       		.sleb128 -21
 1212 025b 0F       		.uleb128 0xf
 1213 025c 58020000 		.4byte	.LASF33
 1214 0260 01       		.byte	0x1
 1215 0261 AA04     		.2byte	0x4aa
 1216 0263 6B000000 		.4byte	0x6b
 1217 0267 02       		.uleb128 0x2
 1218 0268 91       		.byte	0x91
 1219 0269 77       		.sleb128 -9
 1220 026a 00       		.byte	0
 1221 026b 10       		.uleb128 0x10
 1222 026c 04       		.byte	0x4
 1223 026d 71020000 		.4byte	0x271
 1224 0271 11       		.uleb128 0x11
 1225 0272 6B000000 		.4byte	0x6b
 1226 0276 0E       		.uleb128 0xe
 1227 0277 4B020000 		.4byte	.LASF36
 1228 027b 01       		.byte	0x1
 1229 027c CE04     		.2byte	0x4ce
 1230 027e 00000000 		.4byte	.LFB12
 1231 0282 34000000 		.4byte	.LFE12-.LFB12
 1232 0286 01       		.uleb128 0x1
 1233 0287 9C       		.byte	0x9c
 1234 0288 9C020000 		.4byte	0x29c
 1235 028c 0D       		.uleb128 0xd
 1236 028d A4020000 		.4byte	.LASF27
 1237 0291 01       		.byte	0x1
 1238 0292 CE04     		.2byte	0x4ce
 1239 0294 6B000000 		.4byte	0x6b
 1240 0298 02       		.uleb128 0x2
 1241 0299 91       		.byte	0x91
 1242 029a 77       		.sleb128 -9
 1243 029b 00       		.byte	0
 1244 029c 12       		.uleb128 0x12
 1245 029d 86020000 		.4byte	.LASF48
 1246 02a1 01       		.byte	0x1
 1247 02a2 F904     		.2byte	0x4f9
 1248 02a4 6B000000 		.4byte	0x6b
 1249 02a8 00000000 		.4byte	.LFB13
 1250 02ac 48000000 		.4byte	.LFE13-.LFB13
 1251 02b0 01       		.uleb128 0x1
 1252 02b1 9C       		.byte	0x9c
 1253 02b2 C6020000 		.4byte	0x2c6
 1254 02b6 0F       		.uleb128 0xf
 1255 02b7 0F030000 		.4byte	.LASF37
 1256 02bb 01       		.byte	0x1
 1257 02bc FC04     		.2byte	0x4fc
 1258 02be 6B000000 		.4byte	0x6b
 1259 02c2 02       		.uleb128 0x2
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 51


 1260 02c3 91       		.byte	0x91
 1261 02c4 77       		.sleb128 -9
 1262 02c5 00       		.byte	0
 1263 02c6 0E       		.uleb128 0xe
 1264 02c7 C6020000 		.4byte	.LASF38
 1265 02cb 01       		.byte	0x1
 1266 02cc 4A05     		.2byte	0x54a
 1267 02ce 00000000 		.4byte	.LFB14
 1268 02d2 44000000 		.4byte	.LFE14-.LFB14
 1269 02d6 01       		.uleb128 0x1
 1270 02d7 9C       		.byte	0x9c
 1271 02d8 EC020000 		.4byte	0x2ec
 1272 02dc 0F       		.uleb128 0xf
 1273 02dd 57010000 		.4byte	.LASF21
 1274 02e1 01       		.byte	0x1
 1275 02e2 4C05     		.2byte	0x54c
 1276 02e4 6B000000 		.4byte	0x6b
 1277 02e8 02       		.uleb128 0x2
 1278 02e9 91       		.byte	0x91
 1279 02ea 6F       		.sleb128 -17
 1280 02eb 00       		.byte	0
 1281 02ec 0C       		.uleb128 0xc
 1282 02ed B3010000 		.4byte	.LASF39
 1283 02f1 01       		.byte	0x1
 1284 02f2 A005     		.2byte	0x5a0
 1285 02f4 00000000 		.4byte	.LFB15
 1286 02f8 B8000000 		.4byte	.LFE15-.LFB15
 1287 02fc 01       		.uleb128 0x1
 1288 02fd 9C       		.byte	0x9c
 1289 02fe 3D030000 		.4byte	0x33d
 1290 0302 0D       		.uleb128 0xd
 1291 0303 B4020000 		.4byte	.LASF40
 1292 0307 01       		.byte	0x1
 1293 0308 A005     		.2byte	0x5a0
 1294 030a 6B000000 		.4byte	0x6b
 1295 030e 02       		.uleb128 0x2
 1296 030f 91       		.byte	0x91
 1297 0310 6F       		.sleb128 -17
 1298 0311 13       		.uleb128 0x13
 1299 0312 14000000 		.4byte	.LBB2
 1300 0316 88000000 		.4byte	.LBE2-.LBB2
 1301 031a 0F       		.uleb128 0xf
 1302 031b 2E000000 		.4byte	.LASF41
 1303 031f 01       		.byte	0x1
 1304 0320 A805     		.2byte	0x5a8
 1305 0322 6B000000 		.4byte	0x6b
 1306 0326 02       		.uleb128 0x2
 1307 0327 91       		.byte	0x91
 1308 0328 77       		.sleb128 -9
 1309 0329 0F       		.uleb128 0xf
 1310 032a 0E000000 		.4byte	.LASF42
 1311 032e 01       		.byte	0x1
 1312 032f D005     		.2byte	0x5d0
 1313 0331 6B000000 		.4byte	0x6b
 1314 0335 05       		.uleb128 0x5
 1315 0336 03       		.byte	0x3
 1316 0337 01000000 		.4byte	txPeriod.4771
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 52


 1317 033b 00       		.byte	0
 1318 033c 00       		.byte	0
 1319 033d 0C       		.uleb128 0xc
 1320 033e 36000000 		.4byte	.LASF43
 1321 0342 01       		.byte	0x1
 1322 0343 2406     		.2byte	0x624
 1323 0345 00000000 		.4byte	.LFB16
 1324 0349 12000000 		.4byte	.LFE16-.LFB16
 1325 034d 01       		.uleb128 0x1
 1326 034e 9C       		.byte	0x9c
 1327 034f 63030000 		.4byte	0x363
 1328 0353 0D       		.uleb128 0xd
 1329 0354 01010000 		.4byte	.LASF44
 1330 0358 01       		.byte	0x1
 1331 0359 2406     		.2byte	0x624
 1332 035b 6B000000 		.4byte	0x6b
 1333 035f 02       		.uleb128 0x2
 1334 0360 91       		.byte	0x91
 1335 0361 77       		.sleb128 -9
 1336 0362 00       		.byte	0
 1337 0363 14       		.uleb128 0x14
 1338 0364 5F000000 		.4byte	.LASF49
 1339 0368 01       		.byte	0x1
 1340 0369 1B       		.byte	0x1b
 1341 036a 6B000000 		.4byte	0x6b
 1342 036e 05       		.uleb128 0x5
 1343 036f 03       		.byte	0x3
 1344 0370 00000000 		.4byte	UART_initVar
 1345 0374 00       		.byte	0
 1346              		.section	.debug_abbrev,"",%progbits
 1347              	.Ldebug_abbrev0:
 1348 0000 01       		.uleb128 0x1
 1349 0001 11       		.uleb128 0x11
 1350 0002 01       		.byte	0x1
 1351 0003 25       		.uleb128 0x25
 1352 0004 0E       		.uleb128 0xe
 1353 0005 13       		.uleb128 0x13
 1354 0006 0B       		.uleb128 0xb
 1355 0007 03       		.uleb128 0x3
 1356 0008 0E       		.uleb128 0xe
 1357 0009 1B       		.uleb128 0x1b
 1358 000a 0E       		.uleb128 0xe
 1359 000b 55       		.uleb128 0x55
 1360 000c 17       		.uleb128 0x17
 1361 000d 11       		.uleb128 0x11
 1362 000e 01       		.uleb128 0x1
 1363 000f 10       		.uleb128 0x10
 1364 0010 17       		.uleb128 0x17
 1365 0011 00       		.byte	0
 1366 0012 00       		.byte	0
 1367 0013 02       		.uleb128 0x2
 1368 0014 24       		.uleb128 0x24
 1369 0015 00       		.byte	0
 1370 0016 0B       		.uleb128 0xb
 1371 0017 0B       		.uleb128 0xb
 1372 0018 3E       		.uleb128 0x3e
 1373 0019 0B       		.uleb128 0xb
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 53


 1374 001a 03       		.uleb128 0x3
 1375 001b 0E       		.uleb128 0xe
 1376 001c 00       		.byte	0
 1377 001d 00       		.byte	0
 1378 001e 03       		.uleb128 0x3
 1379 001f 24       		.uleb128 0x24
 1380 0020 00       		.byte	0
 1381 0021 0B       		.uleb128 0xb
 1382 0022 0B       		.uleb128 0xb
 1383 0023 3E       		.uleb128 0x3e
 1384 0024 0B       		.uleb128 0xb
 1385 0025 03       		.uleb128 0x3
 1386 0026 08       		.uleb128 0x8
 1387 0027 00       		.byte	0
 1388 0028 00       		.byte	0
 1389 0029 04       		.uleb128 0x4
 1390 002a 16       		.uleb128 0x16
 1391 002b 00       		.byte	0
 1392 002c 03       		.uleb128 0x3
 1393 002d 0E       		.uleb128 0xe
 1394 002e 3A       		.uleb128 0x3a
 1395 002f 0B       		.uleb128 0xb
 1396 0030 3B       		.uleb128 0x3b
 1397 0031 0B       		.uleb128 0xb
 1398 0032 49       		.uleb128 0x49
 1399 0033 13       		.uleb128 0x13
 1400 0034 00       		.byte	0
 1401 0035 00       		.byte	0
 1402 0036 05       		.uleb128 0x5
 1403 0037 16       		.uleb128 0x16
 1404 0038 00       		.byte	0
 1405 0039 03       		.uleb128 0x3
 1406 003a 0E       		.uleb128 0xe
 1407 003b 3A       		.uleb128 0x3a
 1408 003c 0B       		.uleb128 0xb
 1409 003d 3B       		.uleb128 0x3b
 1410 003e 05       		.uleb128 0x5
 1411 003f 49       		.uleb128 0x49
 1412 0040 13       		.uleb128 0x13
 1413 0041 00       		.byte	0
 1414 0042 00       		.byte	0
 1415 0043 06       		.uleb128 0x6
 1416 0044 35       		.uleb128 0x35
 1417 0045 00       		.byte	0
 1418 0046 49       		.uleb128 0x49
 1419 0047 13       		.uleb128 0x13
 1420 0048 00       		.byte	0
 1421 0049 00       		.byte	0
 1422 004a 07       		.uleb128 0x7
 1423 004b 2E       		.uleb128 0x2e
 1424 004c 00       		.byte	0
 1425 004d 3F       		.uleb128 0x3f
 1426 004e 19       		.uleb128 0x19
 1427 004f 03       		.uleb128 0x3
 1428 0050 0E       		.uleb128 0xe
 1429 0051 3A       		.uleb128 0x3a
 1430 0052 0B       		.uleb128 0xb
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 54


 1431 0053 3B       		.uleb128 0x3b
 1432 0054 0B       		.uleb128 0xb
 1433 0055 27       		.uleb128 0x27
 1434 0056 19       		.uleb128 0x19
 1435 0057 11       		.uleb128 0x11
 1436 0058 01       		.uleb128 0x1
 1437 0059 12       		.uleb128 0x12
 1438 005a 06       		.uleb128 0x6
 1439 005b 40       		.uleb128 0x40
 1440 005c 18       		.uleb128 0x18
 1441 005d 9642     		.uleb128 0x2116
 1442 005f 19       		.uleb128 0x19
 1443 0060 00       		.byte	0
 1444 0061 00       		.byte	0
 1445 0062 08       		.uleb128 0x8
 1446 0063 2E       		.uleb128 0x2e
 1447 0064 00       		.byte	0
 1448 0065 3F       		.uleb128 0x3f
 1449 0066 19       		.uleb128 0x19
 1450 0067 03       		.uleb128 0x3
 1451 0068 0E       		.uleb128 0xe
 1452 0069 3A       		.uleb128 0x3a
 1453 006a 0B       		.uleb128 0xb
 1454 006b 3B       		.uleb128 0x3b
 1455 006c 0B       		.uleb128 0xb
 1456 006d 27       		.uleb128 0x27
 1457 006e 19       		.uleb128 0x19
 1458 006f 11       		.uleb128 0x11
 1459 0070 01       		.uleb128 0x1
 1460 0071 12       		.uleb128 0x12
 1461 0072 06       		.uleb128 0x6
 1462 0073 40       		.uleb128 0x40
 1463 0074 18       		.uleb128 0x18
 1464 0075 9742     		.uleb128 0x2117
 1465 0077 19       		.uleb128 0x19
 1466 0078 00       		.byte	0
 1467 0079 00       		.byte	0
 1468 007a 09       		.uleb128 0x9
 1469 007b 2E       		.uleb128 0x2e
 1470 007c 01       		.byte	0x1
 1471 007d 3F       		.uleb128 0x3f
 1472 007e 19       		.uleb128 0x19
 1473 007f 03       		.uleb128 0x3
 1474 0080 0E       		.uleb128 0xe
 1475 0081 3A       		.uleb128 0x3a
 1476 0082 0B       		.uleb128 0xb
 1477 0083 3B       		.uleb128 0x3b
 1478 0084 0B       		.uleb128 0xb
 1479 0085 27       		.uleb128 0x27
 1480 0086 19       		.uleb128 0x19
 1481 0087 11       		.uleb128 0x11
 1482 0088 01       		.uleb128 0x1
 1483 0089 12       		.uleb128 0x12
 1484 008a 06       		.uleb128 0x6
 1485 008b 40       		.uleb128 0x40
 1486 008c 18       		.uleb128 0x18
 1487 008d 9642     		.uleb128 0x2116
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 55


 1488 008f 19       		.uleb128 0x19
 1489 0090 01       		.uleb128 0x1
 1490 0091 13       		.uleb128 0x13
 1491 0092 00       		.byte	0
 1492 0093 00       		.byte	0
 1493 0094 0A       		.uleb128 0xa
 1494 0095 34       		.uleb128 0x34
 1495 0096 00       		.byte	0
 1496 0097 03       		.uleb128 0x3
 1497 0098 0E       		.uleb128 0xe
 1498 0099 3A       		.uleb128 0x3a
 1499 009a 0B       		.uleb128 0xb
 1500 009b 3B       		.uleb128 0x3b
 1501 009c 0B       		.uleb128 0xb
 1502 009d 49       		.uleb128 0x49
 1503 009e 13       		.uleb128 0x13
 1504 009f 02       		.uleb128 0x2
 1505 00a0 18       		.uleb128 0x18
 1506 00a1 00       		.byte	0
 1507 00a2 00       		.byte	0
 1508 00a3 0B       		.uleb128 0xb
 1509 00a4 2E       		.uleb128 0x2e
 1510 00a5 00       		.byte	0
 1511 00a6 3F       		.uleb128 0x3f
 1512 00a7 19       		.uleb128 0x19
 1513 00a8 03       		.uleb128 0x3
 1514 00a9 0E       		.uleb128 0xe
 1515 00aa 3A       		.uleb128 0x3a
 1516 00ab 0B       		.uleb128 0xb
 1517 00ac 3B       		.uleb128 0x3b
 1518 00ad 05       		.uleb128 0x5
 1519 00ae 27       		.uleb128 0x27
 1520 00af 19       		.uleb128 0x19
 1521 00b0 49       		.uleb128 0x49
 1522 00b1 13       		.uleb128 0x13
 1523 00b2 11       		.uleb128 0x11
 1524 00b3 01       		.uleb128 0x1
 1525 00b4 12       		.uleb128 0x12
 1526 00b5 06       		.uleb128 0x6
 1527 00b6 40       		.uleb128 0x40
 1528 00b7 18       		.uleb128 0x18
 1529 00b8 9742     		.uleb128 0x2117
 1530 00ba 19       		.uleb128 0x19
 1531 00bb 00       		.byte	0
 1532 00bc 00       		.byte	0
 1533 00bd 0C       		.uleb128 0xc
 1534 00be 2E       		.uleb128 0x2e
 1535 00bf 01       		.byte	0x1
 1536 00c0 3F       		.uleb128 0x3f
 1537 00c1 19       		.uleb128 0x19
 1538 00c2 03       		.uleb128 0x3
 1539 00c3 0E       		.uleb128 0xe
 1540 00c4 3A       		.uleb128 0x3a
 1541 00c5 0B       		.uleb128 0xb
 1542 00c6 3B       		.uleb128 0x3b
 1543 00c7 05       		.uleb128 0x5
 1544 00c8 27       		.uleb128 0x27
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 56


 1545 00c9 19       		.uleb128 0x19
 1546 00ca 11       		.uleb128 0x11
 1547 00cb 01       		.uleb128 0x1
 1548 00cc 12       		.uleb128 0x12
 1549 00cd 06       		.uleb128 0x6
 1550 00ce 40       		.uleb128 0x40
 1551 00cf 18       		.uleb128 0x18
 1552 00d0 9742     		.uleb128 0x2117
 1553 00d2 19       		.uleb128 0x19
 1554 00d3 01       		.uleb128 0x1
 1555 00d4 13       		.uleb128 0x13
 1556 00d5 00       		.byte	0
 1557 00d6 00       		.byte	0
 1558 00d7 0D       		.uleb128 0xd
 1559 00d8 05       		.uleb128 0x5
 1560 00d9 00       		.byte	0
 1561 00da 03       		.uleb128 0x3
 1562 00db 0E       		.uleb128 0xe
 1563 00dc 3A       		.uleb128 0x3a
 1564 00dd 0B       		.uleb128 0xb
 1565 00de 3B       		.uleb128 0x3b
 1566 00df 05       		.uleb128 0x5
 1567 00e0 49       		.uleb128 0x49
 1568 00e1 13       		.uleb128 0x13
 1569 00e2 02       		.uleb128 0x2
 1570 00e3 18       		.uleb128 0x18
 1571 00e4 00       		.byte	0
 1572 00e5 00       		.byte	0
 1573 00e6 0E       		.uleb128 0xe
 1574 00e7 2E       		.uleb128 0x2e
 1575 00e8 01       		.byte	0x1
 1576 00e9 3F       		.uleb128 0x3f
 1577 00ea 19       		.uleb128 0x19
 1578 00eb 03       		.uleb128 0x3
 1579 00ec 0E       		.uleb128 0xe
 1580 00ed 3A       		.uleb128 0x3a
 1581 00ee 0B       		.uleb128 0xb
 1582 00ef 3B       		.uleb128 0x3b
 1583 00f0 05       		.uleb128 0x5
 1584 00f1 27       		.uleb128 0x27
 1585 00f2 19       		.uleb128 0x19
 1586 00f3 11       		.uleb128 0x11
 1587 00f4 01       		.uleb128 0x1
 1588 00f5 12       		.uleb128 0x12
 1589 00f6 06       		.uleb128 0x6
 1590 00f7 40       		.uleb128 0x40
 1591 00f8 18       		.uleb128 0x18
 1592 00f9 9642     		.uleb128 0x2116
 1593 00fb 19       		.uleb128 0x19
 1594 00fc 01       		.uleb128 0x1
 1595 00fd 13       		.uleb128 0x13
 1596 00fe 00       		.byte	0
 1597 00ff 00       		.byte	0
 1598 0100 0F       		.uleb128 0xf
 1599 0101 34       		.uleb128 0x34
 1600 0102 00       		.byte	0
 1601 0103 03       		.uleb128 0x3
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 57


 1602 0104 0E       		.uleb128 0xe
 1603 0105 3A       		.uleb128 0x3a
 1604 0106 0B       		.uleb128 0xb
 1605 0107 3B       		.uleb128 0x3b
 1606 0108 05       		.uleb128 0x5
 1607 0109 49       		.uleb128 0x49
 1608 010a 13       		.uleb128 0x13
 1609 010b 02       		.uleb128 0x2
 1610 010c 18       		.uleb128 0x18
 1611 010d 00       		.byte	0
 1612 010e 00       		.byte	0
 1613 010f 10       		.uleb128 0x10
 1614 0110 0F       		.uleb128 0xf
 1615 0111 00       		.byte	0
 1616 0112 0B       		.uleb128 0xb
 1617 0113 0B       		.uleb128 0xb
 1618 0114 49       		.uleb128 0x49
 1619 0115 13       		.uleb128 0x13
 1620 0116 00       		.byte	0
 1621 0117 00       		.byte	0
 1622 0118 11       		.uleb128 0x11
 1623 0119 26       		.uleb128 0x26
 1624 011a 00       		.byte	0
 1625 011b 49       		.uleb128 0x49
 1626 011c 13       		.uleb128 0x13
 1627 011d 00       		.byte	0
 1628 011e 00       		.byte	0
 1629 011f 12       		.uleb128 0x12
 1630 0120 2E       		.uleb128 0x2e
 1631 0121 01       		.byte	0x1
 1632 0122 3F       		.uleb128 0x3f
 1633 0123 19       		.uleb128 0x19
 1634 0124 03       		.uleb128 0x3
 1635 0125 0E       		.uleb128 0xe
 1636 0126 3A       		.uleb128 0x3a
 1637 0127 0B       		.uleb128 0xb
 1638 0128 3B       		.uleb128 0x3b
 1639 0129 05       		.uleb128 0x5
 1640 012a 27       		.uleb128 0x27
 1641 012b 19       		.uleb128 0x19
 1642 012c 49       		.uleb128 0x49
 1643 012d 13       		.uleb128 0x13
 1644 012e 11       		.uleb128 0x11
 1645 012f 01       		.uleb128 0x1
 1646 0130 12       		.uleb128 0x12
 1647 0131 06       		.uleb128 0x6
 1648 0132 40       		.uleb128 0x40
 1649 0133 18       		.uleb128 0x18
 1650 0134 9742     		.uleb128 0x2117
 1651 0136 19       		.uleb128 0x19
 1652 0137 01       		.uleb128 0x1
 1653 0138 13       		.uleb128 0x13
 1654 0139 00       		.byte	0
 1655 013a 00       		.byte	0
 1656 013b 13       		.uleb128 0x13
 1657 013c 0B       		.uleb128 0xb
 1658 013d 01       		.byte	0x1
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 58


 1659 013e 11       		.uleb128 0x11
 1660 013f 01       		.uleb128 0x1
 1661 0140 12       		.uleb128 0x12
 1662 0141 06       		.uleb128 0x6
 1663 0142 00       		.byte	0
 1664 0143 00       		.byte	0
 1665 0144 14       		.uleb128 0x14
 1666 0145 34       		.uleb128 0x34
 1667 0146 00       		.byte	0
 1668 0147 03       		.uleb128 0x3
 1669 0148 0E       		.uleb128 0xe
 1670 0149 3A       		.uleb128 0x3a
 1671 014a 0B       		.uleb128 0xb
 1672 014b 3B       		.uleb128 0x3b
 1673 014c 0B       		.uleb128 0xb
 1674 014d 49       		.uleb128 0x49
 1675 014e 13       		.uleb128 0x13
 1676 014f 3F       		.uleb128 0x3f
 1677 0150 19       		.uleb128 0x19
 1678 0151 02       		.uleb128 0x2
 1679 0152 18       		.uleb128 0x18
 1680 0153 00       		.byte	0
 1681 0154 00       		.byte	0
 1682 0155 00       		.byte	0
 1683              		.section	.debug_aranges,"",%progbits
 1684 0000 9C000000 		.4byte	0x9c
 1685 0004 0200     		.2byte	0x2
 1686 0006 00000000 		.4byte	.Ldebug_info0
 1687 000a 04       		.byte	0x4
 1688 000b 00       		.byte	0
 1689 000c 0000     		.2byte	0
 1690 000e 0000     		.2byte	0
 1691 0010 00000000 		.4byte	.LFB0
 1692 0014 24000000 		.4byte	.LFE0-.LFB0
 1693 0018 00000000 		.4byte	.LFB1
 1694 001c 28000000 		.4byte	.LFE1-.LFB1
 1695 0020 00000000 		.4byte	.LFB2
 1696 0024 38000000 		.4byte	.LFE2-.LFB2
 1697 0028 00000000 		.4byte	.LFB3
 1698 002c 38000000 		.4byte	.LFE3-.LFB3
 1699 0030 00000000 		.4byte	.LFB4
 1700 0034 0C000000 		.4byte	.LFE4-.LFB4
 1701 0038 00000000 		.4byte	.LFB5
 1702 003c 12000000 		.4byte	.LFE5-.LFB5
 1703 0040 00000000 		.4byte	.LFB6
 1704 0044 20000000 		.4byte	.LFE6-.LFB6
 1705 0048 00000000 		.4byte	.LFB7
 1706 004c 2C000000 		.4byte	.LFE7-.LFB7
 1707 0050 00000000 		.4byte	.LFB8
 1708 0054 14000000 		.4byte	.LFE8-.LFB8
 1709 0058 00000000 		.4byte	.LFB9
 1710 005c 34000000 		.4byte	.LFE9-.LFB9
 1711 0060 00000000 		.4byte	.LFB10
 1712 0064 54000000 		.4byte	.LFE10-.LFB10
 1713 0068 00000000 		.4byte	.LFB11
 1714 006c 58000000 		.4byte	.LFE11-.LFB11
 1715 0070 00000000 		.4byte	.LFB12
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 59


 1716 0074 34000000 		.4byte	.LFE12-.LFB12
 1717 0078 00000000 		.4byte	.LFB13
 1718 007c 48000000 		.4byte	.LFE13-.LFB13
 1719 0080 00000000 		.4byte	.LFB14
 1720 0084 44000000 		.4byte	.LFE14-.LFB14
 1721 0088 00000000 		.4byte	.LFB15
 1722 008c B8000000 		.4byte	.LFE15-.LFB15
 1723 0090 00000000 		.4byte	.LFB16
 1724 0094 12000000 		.4byte	.LFE16-.LFB16
 1725 0098 00000000 		.4byte	0
 1726 009c 00000000 		.4byte	0
 1727              		.section	.debug_ranges,"",%progbits
 1728              	.Ldebug_ranges0:
 1729 0000 00000000 		.4byte	.LFB0
 1730 0004 24000000 		.4byte	.LFE0
 1731 0008 00000000 		.4byte	.LFB1
 1732 000c 28000000 		.4byte	.LFE1
 1733 0010 00000000 		.4byte	.LFB2
 1734 0014 38000000 		.4byte	.LFE2
 1735 0018 00000000 		.4byte	.LFB3
 1736 001c 38000000 		.4byte	.LFE3
 1737 0020 00000000 		.4byte	.LFB4
 1738 0024 0C000000 		.4byte	.LFE4
 1739 0028 00000000 		.4byte	.LFB5
 1740 002c 12000000 		.4byte	.LFE5
 1741 0030 00000000 		.4byte	.LFB6
 1742 0034 20000000 		.4byte	.LFE6
 1743 0038 00000000 		.4byte	.LFB7
 1744 003c 2C000000 		.4byte	.LFE7
 1745 0040 00000000 		.4byte	.LFB8
 1746 0044 14000000 		.4byte	.LFE8
 1747 0048 00000000 		.4byte	.LFB9
 1748 004c 34000000 		.4byte	.LFE9
 1749 0050 00000000 		.4byte	.LFB10
 1750 0054 54000000 		.4byte	.LFE10
 1751 0058 00000000 		.4byte	.LFB11
 1752 005c 58000000 		.4byte	.LFE11
 1753 0060 00000000 		.4byte	.LFB12
 1754 0064 34000000 		.4byte	.LFE12
 1755 0068 00000000 		.4byte	.LFB13
 1756 006c 48000000 		.4byte	.LFE13
 1757 0070 00000000 		.4byte	.LFB14
 1758 0074 44000000 		.4byte	.LFE14
 1759 0078 00000000 		.4byte	.LFB15
 1760 007c B8000000 		.4byte	.LFE15
 1761 0080 00000000 		.4byte	.LFB16
 1762 0084 12000000 		.4byte	.LFE16
 1763 0088 00000000 		.4byte	0
 1764 008c 00000000 		.4byte	0
 1765              		.section	.debug_line,"",%progbits
 1766              	.Ldebug_line0:
 1767 0000 FB010000 		.section	.debug_str,"MS",%progbits,1
 1767      02004300 
 1767      00000201 
 1767      FB0E0D00 
 1767      01010101 
 1768              	.LASF6:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 60


 1769 0000 6C6F6E67 		.ascii	"long long int\000"
 1769      206C6F6E 
 1769      6720696E 
 1769      7400
 1770              	.LASF42:
 1771 000e 74785065 		.ascii	"txPeriod\000"
 1771      72696F64 
 1771      00
 1772              	.LASF13:
 1773 0017 63686172 		.ascii	"char8\000"
 1773      3800
 1774              	.LASF26:
 1775 001d 55415254 		.ascii	"UART_WriteTxData\000"
 1775      5F577269 
 1775      74655478 
 1775      44617461 
 1775      00
 1776              	.LASF41:
 1777 002e 746D7053 		.ascii	"tmpStat\000"
 1777      74617400 
 1778              	.LASF43:
 1779 0036 55415254 		.ascii	"UART_SetTxAddressMode\000"
 1779      5F536574 
 1779      54784164 
 1779      64726573 
 1779      734D6F64 
 1780              	.LASF3:
 1781 004c 73686F72 		.ascii	"short unsigned int\000"
 1781      7420756E 
 1781      7369676E 
 1781      65642069 
 1781      6E7400
 1782              	.LASF49:
 1783 005f 55415254 		.ascii	"UART_initVar\000"
 1783      5F696E69 
 1783      74566172 
 1783      00
 1784              	.LASF32:
 1785 006c 73747269 		.ascii	"string\000"
 1785      6E6700
 1786              	.LASF11:
 1787 0073 666C6F61 		.ascii	"float\000"
 1787      7400
 1788              	.LASF45:
 1789 0079 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 1789      4320342E 
 1789      382E3420 
 1789      32303134 
 1789      30353236 
 1790 00ac 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 1790      20726576 
 1790      6973696F 
 1790      6E203231 
 1790      31333538 
 1791 00df 30202D66 		.ascii	"0 -ffunction-sections\000"
 1791      66756E63 
 1791      74696F6E 
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 61


 1791      2D736563 
 1791      74696F6E 
 1792              	.LASF19:
 1793 00f5 55415254 		.ascii	"UART_Enable\000"
 1793      5F456E61 
 1793      626C6500 
 1794              	.LASF44:
 1795 0101 61646472 		.ascii	"addressMode\000"
 1795      6573734D 
 1795      6F646500 
 1796              	.LASF18:
 1797 010d 55415254 		.ascii	"UART_Init\000"
 1797      5F496E69 
 1797      7400
 1798              	.LASF15:
 1799 0117 72656738 		.ascii	"reg8\000"
 1799      00
 1800              	.LASF5:
 1801 011c 6C6F6E67 		.ascii	"long unsigned int\000"
 1801      20756E73 
 1801      69676E65 
 1801      6420696E 
 1801      7400
 1802              	.LASF9:
 1803 012e 75696E74 		.ascii	"uint8\000"
 1803      3800
 1804              	.LASF17:
 1805 0134 55415254 		.ascii	"UART_Start\000"
 1805      5F537461 
 1805      727400
 1806              	.LASF34:
 1807 013f 55415254 		.ascii	"UART_PutArray\000"
 1807      5F507574 
 1807      41727261 
 1807      7900
 1808              	.LASF35:
 1809 014d 62797465 		.ascii	"byteCount\000"
 1809      436F756E 
 1809      7400
 1810              	.LASF21:
 1811 0157 656E6162 		.ascii	"enableInterrupts\000"
 1811      6C65496E 
 1811      74657272 
 1811      75707473 
 1811      00
 1812              	.LASF1:
 1813 0168 756E7369 		.ascii	"unsigned char\000"
 1813      676E6564 
 1813      20636861 
 1813      7200
 1814              	.LASF47:
 1815 0176 5A3A5C50 		.ascii	"Z:\\PSoC\\Bootloadable Blinking LED.cydsn\000"
 1815      536F435C 
 1815      426F6F74 
 1815      6C6F6164 
 1815      61626C65 
 1816              	.LASF12:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 62


 1817 019e 646F7562 		.ascii	"double\000"
 1817      6C6500
 1818              	.LASF25:
 1819 01a5 696E7453 		.ascii	"intSrc\000"
 1819      726300
 1820              	.LASF10:
 1821 01ac 75696E74 		.ascii	"uint16\000"
 1821      313600
 1822              	.LASF39:
 1823 01b3 55415254 		.ascii	"UART_SendBreak\000"
 1823      5F53656E 
 1823      64427265 
 1823      616B00
 1824              	.LASF46:
 1825 01c2 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART.c\000"
 1825      6E657261 
 1825      7465645F 
 1825      536F7572 
 1825      63655C50 
 1826              	.LASF8:
 1827 01e2 756E7369 		.ascii	"unsigned int\000"
 1827      676E6564 
 1827      20696E74 
 1827      00
 1828              	.LASF22:
 1829 01ef 55415254 		.ascii	"UART_WriteControlRegister\000"
 1829      5F577269 
 1829      7465436F 
 1829      6E74726F 
 1829      6C526567 
 1830              	.LASF29:
 1831 0209 55415254 		.ascii	"UART_ReadTxStatus\000"
 1831      5F526561 
 1831      64547853 
 1831      74617475 
 1831      7300
 1832              	.LASF7:
 1833 021b 6C6F6E67 		.ascii	"long long unsigned int\000"
 1833      206C6F6E 
 1833      6720756E 
 1833      7369676E 
 1833      65642069 
 1834              	.LASF28:
 1835 0232 55415254 		.ascii	"UART_ReadControlRegister\000"
 1835      5F526561 
 1835      64436F6E 
 1835      74726F6C 
 1835      52656769 
 1836              	.LASF36:
 1837 024b 55415254 		.ascii	"UART_PutCRLF\000"
 1837      5F507574 
 1837      43524C46 
 1837      00
 1838              	.LASF33:
 1839 0258 62756649 		.ascii	"bufIndex\000"
 1839      6E646578 
 1839      00
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 63


 1840              	.LASF23:
 1841 0261 55415254 		.ascii	"UART_SetTxInterruptMode\000"
 1841      5F536574 
 1841      5478496E 
 1841      74657272 
 1841      7570744D 
 1842              	.LASF30:
 1843 0279 55415254 		.ascii	"UART_PutChar\000"
 1843      5F507574 
 1843      43686172 
 1843      00
 1844              	.LASF48:
 1845 0286 55415254 		.ascii	"UART_GetTxBufferSize\000"
 1845      5F476574 
 1845      54784275 
 1845      66666572 
 1845      53697A65 
 1846              	.LASF16:
 1847 029b 73697A65 		.ascii	"sizetype\000"
 1847      74797065 
 1847      00
 1848              	.LASF27:
 1849 02a4 74784461 		.ascii	"txDataByte\000"
 1849      74614279 
 1849      746500
 1850              	.LASF14:
 1851 02af 63686172 		.ascii	"char\000"
 1851      00
 1852              	.LASF40:
 1853 02b4 7265744D 		.ascii	"retMode\000"
 1853      6F646500 
 1854              	.LASF2:
 1855 02bc 73686F72 		.ascii	"short int\000"
 1855      7420696E 
 1855      7400
 1856              	.LASF38:
 1857 02c6 55415254 		.ascii	"UART_ClearTxBuffer\000"
 1857      5F436C65 
 1857      61725478 
 1857      42756666 
 1857      657200
 1858              	.LASF20:
 1859 02d9 55415254 		.ascii	"UART_Stop\000"
 1859      5F53746F 
 1859      7000
 1860              	.LASF24:
 1861 02e3 636F6E74 		.ascii	"control\000"
 1861      726F6C00 
 1862              	.LASF4:
 1863 02eb 6C6F6E67 		.ascii	"long int\000"
 1863      20696E74 
 1863      00
 1864              	.LASF0:
 1865 02f4 7369676E 		.ascii	"signed char\000"
 1865      65642063 
 1865      68617200 
 1866              	.LASF31:
ARM GAS  C:\Users\HASHIM~1\AppData\Local\Temp\ccuFsMNk.s 			page 64


 1867 0300 55415254 		.ascii	"UART_PutString\000"
 1867      5F507574 
 1867      53747269 
 1867      6E6700
 1868              	.LASF37:
 1869 030f 73697A65 		.ascii	"size\000"
 1869      00
 1870              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
